{"ast":null,"code":"import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { withControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\nimport { Animation } from '@motionone/animation';\nfunction timeline(definition) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  const animationDefinitions = createAnimationsFromTimeline(definition, options);\n  /**\r\n   * Create and start animations\r\n   */\n  const animationFactories = animationDefinitions.map(definition => animateStyle(...definition, Animation)).filter(Boolean);\n  return withControls(animationFactories, options,\n  // Get the duration from the first animation definition\n  (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition) {\n  let _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n      defaultOptions = {}\n    } = _a,\n    timelineOptions = __rest(_a, [\"defaultOptions\"]);\n  const animationDefinitions = [];\n  const elementSequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\r\n   * Build the timeline by mapping over the definition array and converting\r\n   * the definitions into keyframes and offsets with absolute time values.\r\n   * These will later get converted into relative offsets in a second pass.\r\n   */\n  for (let i = 0; i < definition.length; i++) {\n    const segment = definition[i];\n    /**\r\n     * If this is a timeline label, mark it and skip the rest of this iteration.\r\n     */\n    if (isString(segment)) {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    const [elementDefinition, keyframes, options = {}] = segment;\n    /**\r\n     * If a relative or absolute time value has been specified we need to resolve\r\n     * it in relation to the currentTime.\r\n     */\n    if (options.at !== undefined) {\n      currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n    }\n    /**\r\n     * Keep track of the maximum duration in this definition. This will be\r\n     * applied to currentTime once the definition has been parsed.\r\n     */\n    let maxDuration = 0;\n    /**\r\n     * Find all the elements specified in the definition and parse value\r\n     * keyframes from their timeline definitions.\r\n     */\n    const elements = resolveElements(elementDefinition, elementCache);\n    const numElements = elements.length;\n    for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n      const element = elements[elementIndex];\n      const elementSequence = getElementSequence(element, elementSequences);\n      for (const key in keyframes) {\n        const valueSequence = getValueSequence(key, elementSequence);\n        let valueKeyframes = keyframesList(keyframes[key]);\n        const valueOptions = getOptions(options, key);\n        let {\n          duration = defaultOptions.duration || defaults.duration,\n          easing = defaultOptions.easing || defaults.easing\n        } = valueOptions;\n        if (isEasingGenerator(easing)) {\n          invariant(key === \"opacity\" || valueKeyframes.length > 1, \"spring must be provided 2 keyframes within timeline()\");\n          const custom = easing.createAnimation(valueKeyframes, key !== \"opacity\", () => 0, key);\n          easing = custom.easing;\n          valueKeyframes = custom.keyframes || valueKeyframes;\n          duration = custom.duration || duration;\n        }\n        const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n        const startTime = currentTime + delay;\n        const targetTime = startTime + duration;\n        /**\r\n         *\r\n         */\n        let {\n          offset = defaultOffset(valueKeyframes.length)\n        } = valueOptions;\n        /**\r\n         * If there's only one offset of 0, fill in a second with length 1\r\n         *\r\n         * TODO: Ensure there's a test that covers this removal\r\n         */\n        if (offset.length === 1 && offset[0] === 0) {\n          offset[1] = 1;\n        }\n        /**\r\n         * Fill out if offset if fewer offsets than keyframes\r\n         */\n        const remainder = offset.length - valueKeyframes.length;\n        remainder > 0 && fillOffset(offset, remainder);\n        /**\r\n         * If only one value has been set, ie [1], push a null to the start of\r\n         * the keyframe array. This will let us mark a keyframe at this point\r\n         * that will later be hydrated with the previous value.\r\n         */\n        valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n        /**\r\n         * Add keyframes, mapping offsets to absolute time.\r\n         */\n        addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n        maxDuration = Math.max(delay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      }\n    }\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\r\n   * For every element and value combination create a new animation.\r\n   */\n  elementSequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\r\n       * Arrange all the keyframes in ascending time order.\r\n       */\n      valueSequence.sort(compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\r\n       * For each keyframe, translate absolute times into\r\n       * relative offsets based on the total duration of the timeline.\r\n       */\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || defaults.easing);\n      }\n      /**\r\n       * If the first keyframe doesn't land on offset: 0\r\n       * provide one by duplicating the initial keyframe. This ensures\r\n       * it snaps to the first keyframe when the animation starts.\r\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(\"linear\");\n      }\n      /**\r\n       * If the last keyframe doesn't land on offset: 1\r\n       * provide one with a null wildcard value. This will ensure it\r\n       * stays static until the end of the animation.\r\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      animationDefinitions.push([element, key, keyframes, Object.assign(Object.assign(Object.assign({}, defaultOptions), {\n        duration: totalDuration,\n        easing: valueEasing,\n        offset: valueOffset\n      }), timelineOptions)]);\n    }\n  });\n  return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n  !sequences.has(element) && sequences.set(element, {});\n  return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nexport { createAnimationsFromTimeline, timeline };","map":{"version":3,"names":["__rest","invariant","isString","defaults","isEasingGenerator","defaultOffset","fillOffset","progress","resolveOption","animateStyle","withControls","keyframesList","getOptions","resolveElements","calcNextTime","addKeyframes","compareByTime","Animation","timeline","definition","options","arguments","length","undefined","_a","animationDefinitions","createAnimationsFromTimeline","animationFactories","map","filter","Boolean","duration","defaultOptions","timelineOptions","elementSequences","Map","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","set","Array","isArray","name","at","elementDefinition","keyframes","maxDuration","elements","numElements","elementIndex","element","elementSequence","getElementSequence","key","valueSequence","getValueSequence","valueKeyframes","valueOptions","easing","custom","createAnimation","delay","startTime","targetTime","offset","remainder","unshift","Math","max","forEach","valueSequences","sort","valueOffset","valueEasing","value","push","Object","assign","sequences","has","get"],"sources":["C:/Users/Кирилл/Desktop/gdfjtgj/pears/frontend/node_modules/@motionone/dom/dist/timeline/index.es.js"],"sourcesContent":["import { __rest } from 'tslib';\r\nimport { invariant } from 'hey-listen';\r\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\r\nimport { resolveOption } from '../utils/stagger.es.js';\r\nimport { animateStyle } from '../animate/animate-style.es.js';\r\nimport { withControls } from '../animate/utils/controls.es.js';\r\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\r\nimport { getOptions } from '../animate/utils/options.es.js';\r\nimport { resolveElements } from '../utils/resolve-elements.es.js';\r\nimport { calcNextTime } from './utils/calc-time.es.js';\r\nimport { addKeyframes } from './utils/edit.es.js';\r\nimport { compareByTime } from './utils/sort.es.js';\r\nimport { Animation } from '@motionone/animation';\r\n\r\nfunction timeline(definition, options = {}) {\r\n    var _a;\r\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\r\n    /**\r\n     * Create and start animations\r\n     */\r\n    const animationFactories = animationDefinitions\r\n        .map((definition) => animateStyle(...definition, Animation))\r\n        .filter(Boolean);\r\n    return withControls(animationFactories, options, \r\n    // Get the duration from the first animation definition\r\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\r\n}\r\nfunction createAnimationsFromTimeline(definition, _a = {}) {\r\n    var { defaultOptions = {} } = _a, timelineOptions = __rest(_a, [\"defaultOptions\"]);\r\n    const animationDefinitions = [];\r\n    const elementSequences = new Map();\r\n    const elementCache = {};\r\n    const timeLabels = new Map();\r\n    let prevTime = 0;\r\n    let currentTime = 0;\r\n    let totalDuration = 0;\r\n    /**\r\n     * Build the timeline by mapping over the definition array and converting\r\n     * the definitions into keyframes and offsets with absolute time values.\r\n     * These will later get converted into relative offsets in a second pass.\r\n     */\r\n    for (let i = 0; i < definition.length; i++) {\r\n        const segment = definition[i];\r\n        /**\r\n         * If this is a timeline label, mark it and skip the rest of this iteration.\r\n         */\r\n        if (isString(segment)) {\r\n            timeLabels.set(segment, currentTime);\r\n            continue;\r\n        }\r\n        else if (!Array.isArray(segment)) {\r\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\r\n            continue;\r\n        }\r\n        const [elementDefinition, keyframes, options = {}] = segment;\r\n        /**\r\n         * If a relative or absolute time value has been specified we need to resolve\r\n         * it in relation to the currentTime.\r\n         */\r\n        if (options.at !== undefined) {\r\n            currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\r\n        }\r\n        /**\r\n         * Keep track of the maximum duration in this definition. This will be\r\n         * applied to currentTime once the definition has been parsed.\r\n         */\r\n        let maxDuration = 0;\r\n        /**\r\n         * Find all the elements specified in the definition and parse value\r\n         * keyframes from their timeline definitions.\r\n         */\r\n        const elements = resolveElements(elementDefinition, elementCache);\r\n        const numElements = elements.length;\r\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\r\n            const element = elements[elementIndex];\r\n            const elementSequence = getElementSequence(element, elementSequences);\r\n            for (const key in keyframes) {\r\n                const valueSequence = getValueSequence(key, elementSequence);\r\n                let valueKeyframes = keyframesList(keyframes[key]);\r\n                const valueOptions = getOptions(options, key);\r\n                let { duration = defaultOptions.duration || defaults.duration, easing = defaultOptions.easing || defaults.easing, } = valueOptions;\r\n                if (isEasingGenerator(easing)) {\r\n                    invariant(key === \"opacity\" || valueKeyframes.length > 1, \"spring must be provided 2 keyframes within timeline()\");\r\n                    const custom = easing.createAnimation(valueKeyframes, key !== \"opacity\", () => 0, key);\r\n                    easing = custom.easing;\r\n                    valueKeyframes = custom.keyframes || valueKeyframes;\r\n                    duration = custom.duration || duration;\r\n                }\r\n                const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\r\n                const startTime = currentTime + delay;\r\n                const targetTime = startTime + duration;\r\n                /**\r\n                 *\r\n                 */\r\n                let { offset = defaultOffset(valueKeyframes.length) } = valueOptions;\r\n                /**\r\n                 * If there's only one offset of 0, fill in a second with length 1\r\n                 *\r\n                 * TODO: Ensure there's a test that covers this removal\r\n                 */\r\n                if (offset.length === 1 && offset[0] === 0) {\r\n                    offset[1] = 1;\r\n                }\r\n                /**\r\n                 * Fill out if offset if fewer offsets than keyframes\r\n                 */\r\n                const remainder = offset.length - valueKeyframes.length;\r\n                remainder > 0 && fillOffset(offset, remainder);\r\n                /**\r\n                 * If only one value has been set, ie [1], push a null to the start of\r\n                 * the keyframe array. This will let us mark a keyframe at this point\r\n                 * that will later be hydrated with the previous value.\r\n                 */\r\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\r\n                /**\r\n                 * Add keyframes, mapping offsets to absolute time.\r\n                 */\r\n                addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\r\n                maxDuration = Math.max(delay + duration, maxDuration);\r\n                totalDuration = Math.max(targetTime, totalDuration);\r\n            }\r\n        }\r\n        prevTime = currentTime;\r\n        currentTime += maxDuration;\r\n    }\r\n    /**\r\n     * For every element and value combination create a new animation.\r\n     */\r\n    elementSequences.forEach((valueSequences, element) => {\r\n        for (const key in valueSequences) {\r\n            const valueSequence = valueSequences[key];\r\n            /**\r\n             * Arrange all the keyframes in ascending time order.\r\n             */\r\n            valueSequence.sort(compareByTime);\r\n            const keyframes = [];\r\n            const valueOffset = [];\r\n            const valueEasing = [];\r\n            /**\r\n             * For each keyframe, translate absolute times into\r\n             * relative offsets based on the total duration of the timeline.\r\n             */\r\n            for (let i = 0; i < valueSequence.length; i++) {\r\n                const { at, value, easing } = valueSequence[i];\r\n                keyframes.push(value);\r\n                valueOffset.push(progress(0, totalDuration, at));\r\n                valueEasing.push(easing || defaults.easing);\r\n            }\r\n            /**\r\n             * If the first keyframe doesn't land on offset: 0\r\n             * provide one by duplicating the initial keyframe. This ensures\r\n             * it snaps to the first keyframe when the animation starts.\r\n             */\r\n            if (valueOffset[0] !== 0) {\r\n                valueOffset.unshift(0);\r\n                keyframes.unshift(keyframes[0]);\r\n                valueEasing.unshift(\"linear\");\r\n            }\r\n            /**\r\n             * If the last keyframe doesn't land on offset: 1\r\n             * provide one with a null wildcard value. This will ensure it\r\n             * stays static until the end of the animation.\r\n             */\r\n            if (valueOffset[valueOffset.length - 1] !== 1) {\r\n                valueOffset.push(1);\r\n                keyframes.push(null);\r\n            }\r\n            animationDefinitions.push([\r\n                element,\r\n                key,\r\n                keyframes,\r\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\r\n            ]);\r\n        }\r\n    });\r\n    return animationDefinitions;\r\n}\r\nfunction getElementSequence(element, sequences) {\r\n    !sequences.has(element) && sequences.set(element, {});\r\n    return sequences.get(element);\r\n}\r\nfunction getValueSequence(name, sequences) {\r\n    if (!sequences[name])\r\n        sequences[name] = [];\r\n    return sequences[name];\r\n}\r\n\r\nexport { createAnimationsFromTimeline, timeline };\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,OAAO;AAC9B,SAASC,SAAS,QAAQ,YAAY;AACtC,SAASC,QAAQ,EAAEC,QAAQ,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,QAAQ,kBAAkB;AAC7G,SAASC,aAAa,QAAQ,wBAAwB;AACtD,SAASC,YAAY,QAAQ,gCAAgC;AAC7D,SAASC,YAAY,QAAQ,iCAAiC;AAC9D,SAASC,aAAa,QAAQ,kCAAkC;AAChE,SAASC,UAAU,QAAQ,gCAAgC;AAC3D,SAASC,eAAe,QAAQ,iCAAiC;AACjE,SAASC,YAAY,QAAQ,yBAAyB;AACtD,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,SAAS,QAAQ,sBAAsB;AAEhD,SAASC,QAAQA,CAACC,UAAU,EAAgB;EAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACtC,IAAIG,EAAE;EACN,MAAMC,oBAAoB,GAAGC,4BAA4B,CAACP,UAAU,EAAEC,OAAO,CAAC;EAC9E;AACJ;AACA;EACI,MAAMO,kBAAkB,GAAGF,oBAAoB,CAC1CG,GAAG,CAAET,UAAU,IAAKV,YAAY,CAAC,GAAGU,UAAU,EAAEF,SAAS,CAAC,CAAC,CAC3DY,MAAM,CAACC,OAAO,CAAC;EACpB,OAAOpB,YAAY,CAACiB,kBAAkB,EAAEP,OAAO;EAC/C;EACA,CAACI,EAAE,GAAGC,oBAAoB,CAAC,CAAC,CAAC,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAACO,QAAQ,CAAC;AACvF;AACA,SAASL,4BAA4BA,CAACP,UAAU,EAAW;EAAA,IAATK,EAAE,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACrD,IAAI;MAAEW,cAAc,GAAG,CAAC;IAAE,CAAC,GAAGR,EAAE;IAAES,eAAe,GAAGjC,MAAM,CAACwB,EAAE,EAAE,CAAC,gBAAgB,CAAC,CAAC;EAClF,MAAMC,oBAAoB,GAAG,EAAE;EAC/B,MAAMS,gBAAgB,GAAG,IAAIC,GAAG,EAAE;EAClC,MAAMC,YAAY,GAAG,CAAC,CAAC;EACvB,MAAMC,UAAU,GAAG,IAAIF,GAAG,EAAE;EAC5B,IAAIG,QAAQ,GAAG,CAAC;EAChB,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,aAAa,GAAG,CAAC;EACrB;AACJ;AACA;AACA;AACA;EACI,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,UAAU,CAACG,MAAM,EAAEmB,CAAC,EAAE,EAAE;IACxC,MAAMC,OAAO,GAAGvB,UAAU,CAACsB,CAAC,CAAC;IAC7B;AACR;AACA;IACQ,IAAIvC,QAAQ,CAACwC,OAAO,CAAC,EAAE;MACnBL,UAAU,CAACM,GAAG,CAACD,OAAO,EAAEH,WAAW,CAAC;MACpC;IACJ,CAAC,MACI,IAAI,CAACK,KAAK,CAACC,OAAO,CAACH,OAAO,CAAC,EAAE;MAC9BL,UAAU,CAACM,GAAG,CAACD,OAAO,CAACI,IAAI,EAAEhC,YAAY,CAACyB,WAAW,EAAEG,OAAO,CAACK,EAAE,EAAET,QAAQ,EAAED,UAAU,CAAC,CAAC;MACzF;IACJ;IACA,MAAM,CAACW,iBAAiB,EAAEC,SAAS,EAAE7B,OAAO,GAAG,CAAC,CAAC,CAAC,GAAGsB,OAAO;IAC5D;AACR;AACA;AACA;IACQ,IAAItB,OAAO,CAAC2B,EAAE,KAAKxB,SAAS,EAAE;MAC1BgB,WAAW,GAAGzB,YAAY,CAACyB,WAAW,EAAEnB,OAAO,CAAC2B,EAAE,EAAET,QAAQ,EAAED,UAAU,CAAC;IAC7E;IACA;AACR;AACA;AACA;IACQ,IAAIa,WAAW,GAAG,CAAC;IACnB;AACR;AACA;AACA;IACQ,MAAMC,QAAQ,GAAGtC,eAAe,CAACmC,iBAAiB,EAAEZ,YAAY,CAAC;IACjE,MAAMgB,WAAW,GAAGD,QAAQ,CAAC7B,MAAM;IACnC,KAAK,IAAI+B,YAAY,GAAG,CAAC,EAAEA,YAAY,GAAGD,WAAW,EAAEC,YAAY,EAAE,EAAE;MACnE,MAAMC,OAAO,GAAGH,QAAQ,CAACE,YAAY,CAAC;MACtC,MAAME,eAAe,GAAGC,kBAAkB,CAACF,OAAO,EAAEpB,gBAAgB,CAAC;MACrE,KAAK,MAAMuB,GAAG,IAAIR,SAAS,EAAE;QACzB,MAAMS,aAAa,GAAGC,gBAAgB,CAACF,GAAG,EAAEF,eAAe,CAAC;QAC5D,IAAIK,cAAc,GAAGjD,aAAa,CAACsC,SAAS,CAACQ,GAAG,CAAC,CAAC;QAClD,MAAMI,YAAY,GAAGjD,UAAU,CAACQ,OAAO,EAAEqC,GAAG,CAAC;QAC7C,IAAI;UAAE1B,QAAQ,GAAGC,cAAc,CAACD,QAAQ,IAAI5B,QAAQ,CAAC4B,QAAQ;UAAE+B,MAAM,GAAG9B,cAAc,CAAC8B,MAAM,IAAI3D,QAAQ,CAAC2D;QAAQ,CAAC,GAAGD,YAAY;QAClI,IAAIzD,iBAAiB,CAAC0D,MAAM,CAAC,EAAE;UAC3B7D,SAAS,CAACwD,GAAG,KAAK,SAAS,IAAIG,cAAc,CAACtC,MAAM,GAAG,CAAC,EAAE,uDAAuD,CAAC;UAClH,MAAMyC,MAAM,GAAGD,MAAM,CAACE,eAAe,CAACJ,cAAc,EAAEH,GAAG,KAAK,SAAS,EAAE,MAAM,CAAC,EAAEA,GAAG,CAAC;UACtFK,MAAM,GAAGC,MAAM,CAACD,MAAM;UACtBF,cAAc,GAAGG,MAAM,CAACd,SAAS,IAAIW,cAAc;UACnD7B,QAAQ,GAAGgC,MAAM,CAAChC,QAAQ,IAAIA,QAAQ;QAC1C;QACA,MAAMkC,KAAK,GAAGzD,aAAa,CAACY,OAAO,CAAC6C,KAAK,EAAEZ,YAAY,EAAED,WAAW,CAAC,IAAI,CAAC;QAC1E,MAAMc,SAAS,GAAG3B,WAAW,GAAG0B,KAAK;QACrC,MAAME,UAAU,GAAGD,SAAS,GAAGnC,QAAQ;QACvC;AAChB;AACA;QACgB,IAAI;UAAEqC,MAAM,GAAG/D,aAAa,CAACuD,cAAc,CAACtC,MAAM;QAAE,CAAC,GAAGuC,YAAY;QACpE;AAChB;AACA;AACA;AACA;QACgB,IAAIO,MAAM,CAAC9C,MAAM,KAAK,CAAC,IAAI8C,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;UACxCA,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;QACjB;QACA;AAChB;AACA;QACgB,MAAMC,SAAS,GAAGD,MAAM,CAAC9C,MAAM,GAAGsC,cAAc,CAACtC,MAAM;QACvD+C,SAAS,GAAG,CAAC,IAAI/D,UAAU,CAAC8D,MAAM,EAAEC,SAAS,CAAC;QAC9C;AAChB;AACA;AACA;AACA;QACgBT,cAAc,CAACtC,MAAM,KAAK,CAAC,IAAIsC,cAAc,CAACU,OAAO,CAAC,IAAI,CAAC;QAC3D;AAChB;AACA;QACgBvD,YAAY,CAAC2C,aAAa,EAAEE,cAAc,EAAEE,MAAM,EAAEM,MAAM,EAAEF,SAAS,EAAEC,UAAU,CAAC;QAClFjB,WAAW,GAAGqB,IAAI,CAACC,GAAG,CAACP,KAAK,GAAGlC,QAAQ,EAAEmB,WAAW,CAAC;QACrDV,aAAa,GAAG+B,IAAI,CAACC,GAAG,CAACL,UAAU,EAAE3B,aAAa,CAAC;MACvD;IACJ;IACAF,QAAQ,GAAGC,WAAW;IACtBA,WAAW,IAAIW,WAAW;EAC9B;EACA;AACJ;AACA;EACIhB,gBAAgB,CAACuC,OAAO,CAAC,CAACC,cAAc,EAAEpB,OAAO,KAAK;IAClD,KAAK,MAAMG,GAAG,IAAIiB,cAAc,EAAE;MAC9B,MAAMhB,aAAa,GAAGgB,cAAc,CAACjB,GAAG,CAAC;MACzC;AACZ;AACA;MACYC,aAAa,CAACiB,IAAI,CAAC3D,aAAa,CAAC;MACjC,MAAMiC,SAAS,GAAG,EAAE;MACpB,MAAM2B,WAAW,GAAG,EAAE;MACtB,MAAMC,WAAW,GAAG,EAAE;MACtB;AACZ;AACA;AACA;MACY,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,aAAa,CAACpC,MAAM,EAAEmB,CAAC,EAAE,EAAE;QAC3C,MAAM;UAAEM,EAAE;UAAE+B,KAAK;UAAEhB;QAAO,CAAC,GAAGJ,aAAa,CAACjB,CAAC,CAAC;QAC9CQ,SAAS,CAAC8B,IAAI,CAACD,KAAK,CAAC;QACrBF,WAAW,CAACG,IAAI,CAACxE,QAAQ,CAAC,CAAC,EAAEiC,aAAa,EAAEO,EAAE,CAAC,CAAC;QAChD8B,WAAW,CAACE,IAAI,CAACjB,MAAM,IAAI3D,QAAQ,CAAC2D,MAAM,CAAC;MAC/C;MACA;AACZ;AACA;AACA;AACA;MACY,IAAIc,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;QACtBA,WAAW,CAACN,OAAO,CAAC,CAAC,CAAC;QACtBrB,SAAS,CAACqB,OAAO,CAACrB,SAAS,CAAC,CAAC,CAAC,CAAC;QAC/B4B,WAAW,CAACP,OAAO,CAAC,QAAQ,CAAC;MACjC;MACA;AACZ;AACA;AACA;AACA;MACY,IAAIM,WAAW,CAACA,WAAW,CAACtD,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;QAC3CsD,WAAW,CAACG,IAAI,CAAC,CAAC,CAAC;QACnB9B,SAAS,CAAC8B,IAAI,CAAC,IAAI,CAAC;MACxB;MACAtD,oBAAoB,CAACsD,IAAI,CAAC,CACtBzB,OAAO,EACPG,GAAG,EACHR,SAAS,EACT+B,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEjD,cAAc,CAAC,EAAE;QAAED,QAAQ,EAAES,aAAa;QAAEsB,MAAM,EAAEe,WAAW;QAAET,MAAM,EAAEQ;MAAY,CAAC,CAAC,EAAE3C,eAAe,CAAC,CAC1J,CAAC;IACN;EACJ,CAAC,CAAC;EACF,OAAOR,oBAAoB;AAC/B;AACA,SAAS+B,kBAAkBA,CAACF,OAAO,EAAE4B,SAAS,EAAE;EAC5C,CAACA,SAAS,CAACC,GAAG,CAAC7B,OAAO,CAAC,IAAI4B,SAAS,CAACvC,GAAG,CAACW,OAAO,EAAE,CAAC,CAAC,CAAC;EACrD,OAAO4B,SAAS,CAACE,GAAG,CAAC9B,OAAO,CAAC;AACjC;AACA,SAASK,gBAAgBA,CAACb,IAAI,EAAEoC,SAAS,EAAE;EACvC,IAAI,CAACA,SAAS,CAACpC,IAAI,CAAC,EAChBoC,SAAS,CAACpC,IAAI,CAAC,GAAG,EAAE;EACxB,OAAOoC,SAAS,CAACpC,IAAI,CAAC;AAC1B;AAEA,SAASpB,4BAA4B,EAAER,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}