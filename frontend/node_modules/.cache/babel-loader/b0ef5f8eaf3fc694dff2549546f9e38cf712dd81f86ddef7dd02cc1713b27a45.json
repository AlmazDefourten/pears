{"ast":null,"code":"import { findSpring, calcAngularFreq } from './find-spring.mjs';\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false,\n    ...options\n  };\n  // stiffness/damping/mass overrides duration/bounce\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = {\n      ...springOptions,\n      ...derived,\n      velocity: 0.0,\n      mass: 1.0\n    };\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nconst velocitySampleDuration = 5;\n/**\r\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\r\n */\nfunction spring(_ref) {\n  let {\n    keyframes,\n    restDelta,\n    restSpeed,\n    ...options\n  } = _ref;\n  let origin = keyframes[0];\n  let target = keyframes[keyframes.length - 1];\n  /**\r\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n   * to reduce GC during animation.\r\n   */\n  const state = {\n    done: false,\n    value: origin\n  };\n  const {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  function createSpring() {\n    const initialDelta = target - origin;\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    /**\r\n     * If we're working on a granular scale, use smaller defaults for determining\r\n     * when the spring is finished.\r\n     *\r\n     * These defaults have been selected emprically based on what strikes a good\r\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\r\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      // Underdamped spring\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      // Critically damped spring\n      resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      // Overdamped spring\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        // When performing sinh or cosh values can hit Infinity so we cap them here\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: t => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        let currentVelocity = initialVelocity;\n        if (t !== 0) {\n          /**\r\n           * We only need to calculate velocity for under-damped springs\r\n           * as over- and critically-damped springs can't overshoot, so\r\n           * checking only for displacement is enough.\r\n           */\n          if (dampingRatio < 1) {\n            const prevT = Math.max(0, t - velocitySampleDuration);\n            currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t - prevT);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? target : current;\n      return state;\n    },\n    flipTarget: () => {\n      initialVelocity = -initialVelocity;\n      [origin, target] = [target, origin];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = _t => 0;\nexport { spring };","map":{"version":3,"names":["findSpring","calcAngularFreq","velocityPerSecond","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","stiffness","damping","mass","isResolvedFromDuration","derived","velocitySampleDuration","spring","_ref","keyframes","restDelta","restSpeed","origin","target","length","state","done","value","duration","resolveSpring","zero","initialVelocity","dampingRatio","Math","sqrt","createSpring","initialDelta","undampedAngularFreq","isGranularScale","abs","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","next","current","currentVelocity","prevT","max","isBelowVelocityThreshold","isBelowDisplacementThreshold","flipTarget","needsInterpolation","a","b","_t"],"sources":["C:/Users/Кирилл/Desktop/here/pears/frontend/node_modules/framer-motion/dist/es/animation/legacy-popmotion/spring.mjs"],"sourcesContent":["import { findSpring, calcAngularFreq } from './find-spring.mjs';\r\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\r\n\r\nconst durationKeys = [\"duration\", \"bounce\"];\r\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\r\nfunction isSpringType(options, keys) {\r\n    return keys.some((key) => options[key] !== undefined);\r\n}\r\nfunction getSpringOptions(options) {\r\n    let springOptions = {\r\n        velocity: 0.0,\r\n        stiffness: 100,\r\n        damping: 10,\r\n        mass: 1.0,\r\n        isResolvedFromDuration: false,\r\n        ...options,\r\n    };\r\n    // stiffness/damping/mass overrides duration/bounce\r\n    if (!isSpringType(options, physicsKeys) &&\r\n        isSpringType(options, durationKeys)) {\r\n        const derived = findSpring(options);\r\n        springOptions = {\r\n            ...springOptions,\r\n            ...derived,\r\n            velocity: 0.0,\r\n            mass: 1.0,\r\n        };\r\n        springOptions.isResolvedFromDuration = true;\r\n    }\r\n    return springOptions;\r\n}\r\nconst velocitySampleDuration = 5;\r\n/**\r\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\r\n */\r\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\r\n    let origin = keyframes[0];\r\n    let target = keyframes[keyframes.length - 1];\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = { done: false, value: origin };\r\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\r\n    let resolveSpring = zero;\r\n    let initialVelocity = velocity ? -(velocity / 1000) : 0.0;\r\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\r\n    function createSpring() {\r\n        const initialDelta = target - origin;\r\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\r\n        /**\r\n         * If we're working on a granular scale, use smaller defaults for determining\r\n         * when the spring is finished.\r\n         *\r\n         * These defaults have been selected emprically based on what strikes a good\r\n         * ratio between feeling good and finishing as soon as changes are imperceptible.\r\n         */\r\n        const isGranularScale = Math.abs(initialDelta) < 5;\r\n        restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\r\n        restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\r\n        if (dampingRatio < 1) {\r\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\r\n            // Underdamped spring\r\n            resolveSpring = (t) => {\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                return (target -\r\n                    envelope *\r\n                        (((initialVelocity +\r\n                            dampingRatio * undampedAngularFreq * initialDelta) /\r\n                            angularFreq) *\r\n                            Math.sin(angularFreq * t) +\r\n                            initialDelta * Math.cos(angularFreq * t)));\r\n            };\r\n        }\r\n        else if (dampingRatio === 1) {\r\n            // Critically damped spring\r\n            resolveSpring = (t) => target -\r\n                Math.exp(-undampedAngularFreq * t) *\r\n                    (initialDelta +\r\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\r\n                            t);\r\n        }\r\n        else {\r\n            // Overdamped spring\r\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\r\n            resolveSpring = (t) => {\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                // When performing sinh or cosh values can hit Infinity so we cap them here\r\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\r\n                return (target -\r\n                    (envelope *\r\n                        ((initialVelocity +\r\n                            dampingRatio * undampedAngularFreq * initialDelta) *\r\n                            Math.sinh(freqForT) +\r\n                            dampedAngularFreq *\r\n                                initialDelta *\r\n                                Math.cosh(freqForT))) /\r\n                        dampedAngularFreq);\r\n            };\r\n        }\r\n    }\r\n    createSpring();\r\n    return {\r\n        next: (t) => {\r\n            const current = resolveSpring(t);\r\n            if (!isResolvedFromDuration) {\r\n                let currentVelocity = initialVelocity;\r\n                if (t !== 0) {\r\n                    /**\r\n                     * We only need to calculate velocity for under-damped springs\r\n                     * as over- and critically-damped springs can't overshoot, so\r\n                     * checking only for displacement is enough.\r\n                     */\r\n                    if (dampingRatio < 1) {\r\n                        const prevT = Math.max(0, t - velocitySampleDuration);\r\n                        currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t - prevT);\r\n                    }\r\n                    else {\r\n                        currentVelocity = 0;\r\n                    }\r\n                }\r\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\r\n                state.done =\r\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n            }\r\n            else {\r\n                state.done = t >= duration;\r\n            }\r\n            state.value = state.done ? target : current;\r\n            return state;\r\n        },\r\n        flipTarget: () => {\r\n            initialVelocity = -initialVelocity;\r\n            [origin, target] = [target, origin];\r\n            createSpring();\r\n        },\r\n    };\r\n}\r\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\r\nconst zero = (_t) => 0;\r\n\r\nexport { spring };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}