{"ast":null,"code":"import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\nimport { isNumber, isString, noopReturn } from '@motionone/utils';\nimport { getUnitConverter } from '../animate/utils/get-unit.es.js';\nimport { transformDefinitions } from '../animate/utils/transforms.es.js';\nimport { getStyleName } from '../animate/utils/get-style-name.es.js';\nfunction canGenerate(value) {\n  return isNumber(value) && !isNaN(value);\n}\nfunction getAsNumber(value) {\n  return isString(value) ? parseFloat(value) : value;\n}\nfunction createGeneratorEasing(createGenerator) {\n  const keyframesCache = new WeakMap();\n  return function () {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const generatorCache = new Map();\n    const getGenerator = function () {\n      let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      let velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      let isScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      const key = `${from}-${to}-${velocity}-${isScale}`;\n      if (!generatorCache.has(key)) {\n        generatorCache.set(key, createGenerator(Object.assign({\n          from,\n          to,\n          velocity,\n          restSpeed: isScale ? 0.05 : 2,\n          restDistance: isScale ? 0.01 : 0.5\n        }, options)));\n      }\n      return generatorCache.get(key);\n    };\n    const getKeyframes = (generator, toUnit) => {\n      if (!keyframesCache.has(generator)) {\n        keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));\n      }\n      return keyframesCache.get(generator);\n    };\n    return {\n      createAnimation: function (keyframes) {\n        let shouldGenerate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        let getOrigin = arguments.length > 2 ? arguments[2] : undefined;\n        let name = arguments.length > 3 ? arguments[3] : undefined;\n        let motionValue = arguments.length > 4 ? arguments[4] : undefined;\n        let settings;\n        let origin;\n        let target;\n        let velocity = 0;\n        let toUnit = noopReturn;\n        const numKeyframes = keyframes.length;\n        /**\r\n         * If we should generate an animation for this value, run some preperation\r\n         * like resolving target/origin, finding a unit (if any) and determine if\r\n         * it is actually possible to generate.\r\n         */\n        if (shouldGenerate) {\n          toUnit = getUnitConverter(keyframes, name ? transformDefinitions.get(getStyleName(name)) : undefined);\n          const targetDefinition = keyframes[numKeyframes - 1];\n          target = getAsNumber(targetDefinition);\n          if (numKeyframes > 1 && keyframes[0] !== null) {\n            /**\r\n             * If we have multiple keyframes, take the initial keyframe as the origin.\r\n             */\n            origin = getAsNumber(keyframes[0]);\n          } else {\n            const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n            /**\r\n             * If we have an existing generator for this value we can use it to resolve\r\n             * the animation's current value and velocity.\r\n             */\n            if (prevGenerator) {\n              /**\r\n               * If we have a generator for this value we can use it to resolve\r\n               * the animations's current value and velocity.\r\n               */\n              const {\n                animation,\n                generatorStartTime\n              } = motionValue;\n              const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n              const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n              const prevGeneratorCurrent = prevGenerator(currentTime).current;\n              origin = prevGeneratorCurrent;\n              velocity = calcGeneratorVelocity(t => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\n            } else if (getOrigin) {\n              /**\r\n               * As a last resort, read the origin from the DOM.\r\n               */\n              origin = getAsNumber(getOrigin());\n            }\n          }\n        }\n        /**\r\n         * If we've determined it is possible to generate an animation, do so.\r\n         */\n        if (canGenerate(origin) && canGenerate(target)) {\n          const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n          settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), {\n            easing: \"linear\"\n          });\n          // TODO Add test for this\n          if (motionValue) {\n            motionValue.generator = generator;\n            motionValue.generatorStartTime = performance.now();\n          }\n        }\n        /**\r\n         * If by now we haven't generated a set of keyframes, create a generic generator\r\n         * based on the provided props that animates from 0-100 to fetch a rough\r\n         * \"overshootDuration\" - the moment when the generator first hits the animation target.\r\n         * Then return animation settings that will run a normal animation for that duration.\r\n         */\n        if (!settings) {\n          const keyframesMetadata = getKeyframes(getGenerator(0, 100));\n          settings = {\n            easing: \"ease\",\n            duration: keyframesMetadata.overshootDuration\n          };\n        }\n        return settings;\n      }\n    };\n  };\n}\nexport { createGeneratorEasing };","map":{"version":3,"names":["calcGeneratorVelocity","pregenerateKeyframes","isNumber","isString","noopReturn","getUnitConverter","transformDefinitions","getStyleName","canGenerate","value","isNaN","getAsNumber","parseFloat","createGeneratorEasing","createGenerator","keyframesCache","WeakMap","options","arguments","length","undefined","generatorCache","Map","getGenerator","from","to","velocity","isScale","key","has","set","Object","assign","restSpeed","restDistance","get","getKeyframes","generator","toUnit","createAnimation","keyframes","shouldGenerate","getOrigin","name","motionValue","settings","origin","target","numKeyframes","targetDefinition","prevGenerator","animation","generatorStartTime","startTime","currentTime","performance","now","prevGeneratorCurrent","current","t","includes","easing","keyframesMetadata","duration","overshootDuration"],"sources":["C:/Users/Кирилл/Desktop/here/pears/frontend/node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js"],"sourcesContent":["import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\r\nimport { isNumber, isString, noopReturn } from '@motionone/utils';\r\nimport { getUnitConverter } from '../animate/utils/get-unit.es.js';\r\nimport { transformDefinitions } from '../animate/utils/transforms.es.js';\r\nimport { getStyleName } from '../animate/utils/get-style-name.es.js';\r\n\r\nfunction canGenerate(value) {\r\n    return isNumber(value) && !isNaN(value);\r\n}\r\nfunction getAsNumber(value) {\r\n    return isString(value) ? parseFloat(value) : value;\r\n}\r\nfunction createGeneratorEasing(createGenerator) {\r\n    const keyframesCache = new WeakMap();\r\n    return (options = {}) => {\r\n        const generatorCache = new Map();\r\n        const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\r\n            const key = `${from}-${to}-${velocity}-${isScale}`;\r\n            if (!generatorCache.has(key)) {\r\n                generatorCache.set(key, createGenerator(Object.assign({ from,\r\n                    to,\r\n                    velocity, restSpeed: isScale ? 0.05 : 2, restDistance: isScale ? 0.01 : 0.5 }, options)));\r\n            }\r\n            return generatorCache.get(key);\r\n        };\r\n        const getKeyframes = (generator, toUnit) => {\r\n            if (!keyframesCache.has(generator)) {\r\n                keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));\r\n            }\r\n            return keyframesCache.get(generator);\r\n        };\r\n        return {\r\n            createAnimation: (keyframes, shouldGenerate = true, getOrigin, name, motionValue) => {\r\n                let settings;\r\n                let origin;\r\n                let target;\r\n                let velocity = 0;\r\n                let toUnit = noopReturn;\r\n                const numKeyframes = keyframes.length;\r\n                /**\r\n                 * If we should generate an animation for this value, run some preperation\r\n                 * like resolving target/origin, finding a unit (if any) and determine if\r\n                 * it is actually possible to generate.\r\n                 */\r\n                if (shouldGenerate) {\r\n                    toUnit = getUnitConverter(keyframes, name ? transformDefinitions.get(getStyleName(name)) : undefined);\r\n                    const targetDefinition = keyframes[numKeyframes - 1];\r\n                    target = getAsNumber(targetDefinition);\r\n                    if (numKeyframes > 1 && keyframes[0] !== null) {\r\n                        /**\r\n                         * If we have multiple keyframes, take the initial keyframe as the origin.\r\n                         */\r\n                        origin = getAsNumber(keyframes[0]);\r\n                    }\r\n                    else {\r\n                        const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\r\n                        /**\r\n                         * If we have an existing generator for this value we can use it to resolve\r\n                         * the animation's current value and velocity.\r\n                         */\r\n                        if (prevGenerator) {\r\n                            /**\r\n                             * If we have a generator for this value we can use it to resolve\r\n                             * the animations's current value and velocity.\r\n                             */\r\n                            const { animation, generatorStartTime } = motionValue;\r\n                            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\r\n                            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\r\n                            const prevGeneratorCurrent = prevGenerator(currentTime).current;\r\n                            origin = prevGeneratorCurrent;\r\n                            velocity = calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\r\n                        }\r\n                        else if (getOrigin) {\r\n                            /**\r\n                             * As a last resort, read the origin from the DOM.\r\n                             */\r\n                            origin = getAsNumber(getOrigin());\r\n                        }\r\n                    }\r\n                }\r\n                /**\r\n                 * If we've determined it is possible to generate an animation, do so.\r\n                 */\r\n                if (canGenerate(origin) && canGenerate(target)) {\r\n                    const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\r\n                    settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), { easing: \"linear\" });\r\n                    // TODO Add test for this\r\n                    if (motionValue) {\r\n                        motionValue.generator = generator;\r\n                        motionValue.generatorStartTime = performance.now();\r\n                    }\r\n                }\r\n                /**\r\n                 * If by now we haven't generated a set of keyframes, create a generic generator\r\n                 * based on the provided props that animates from 0-100 to fetch a rough\r\n                 * \"overshootDuration\" - the moment when the generator first hits the animation target.\r\n                 * Then return animation settings that will run a normal animation for that duration.\r\n                 */\r\n                if (!settings) {\r\n                    const keyframesMetadata = getKeyframes(getGenerator(0, 100));\r\n                    settings = {\r\n                        easing: \"ease\",\r\n                        duration: keyframesMetadata.overshootDuration,\r\n                    };\r\n                }\r\n                return settings;\r\n            },\r\n        };\r\n    };\r\n}\r\n\r\nexport { createGeneratorEasing };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}