{"ast":null,"code":"function decay(_ref) {\n  let {\n    /**\r\n     * The decay animation dynamically calculates an end of the animation\r\n     * based on the initial keyframe, so we only need to define a single keyframe\r\n     * as default.\r\n     */\n    keyframes = [0],\n    velocity = 0,\n    power = 0.8,\n    timeConstant = 350,\n    restDelta = 0.5,\n    modifyTarget\n  } = _ref;\n  const origin = keyframes[0];\n  /**\r\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n   * to reduce GC during animation.\r\n   */\n  const state = {\n    done: false,\n    value: origin\n  };\n  let amplitude = power * velocity;\n  const ideal = origin + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\r\n   * If the target has changed we need to re-calculate the amplitude, otherwise\r\n   * the animation will start from the wrong position.\r\n   */\n  if (target !== ideal) amplitude = target - origin;\n  return {\n    next: t => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {}\n  };\n}\nexport { decay };","map":{"version":3,"names":["decay","_ref","keyframes","velocity","power","timeConstant","restDelta","modifyTarget","origin","state","done","value","amplitude","ideal","target","undefined","next","t","delta","Math","exp","flipTarget"],"sources":["C:/Users/Кирилл/Desktop/here/pears/frontend/node_modules/framer-motion/dist/es/animation/legacy-popmotion/decay.mjs"],"sourcesContent":["function decay({ \r\n/**\r\n * The decay animation dynamically calculates an end of the animation\r\n * based on the initial keyframe, so we only need to define a single keyframe\r\n * as default.\r\n */\r\nkeyframes = [0], velocity = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {\r\n    const origin = keyframes[0];\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = { done: false, value: origin };\r\n    let amplitude = power * velocity;\r\n    const ideal = origin + amplitude;\r\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\r\n    /**\r\n     * If the target has changed we need to re-calculate the amplitude, otherwise\r\n     * the animation will start from the wrong position.\r\n     */\r\n    if (target !== ideal)\r\n        amplitude = target - origin;\r\n    return {\r\n        next: (t) => {\r\n            const delta = -amplitude * Math.exp(-t / timeConstant);\r\n            state.done = !(delta > restDelta || delta < -restDelta);\r\n            state.value = state.done ? target : target + delta;\r\n            return state;\r\n        },\r\n        flipTarget: () => { },\r\n    };\r\n}\r\n\r\nexport { decay };\r\n"],"mappings":"AAAA,SAASA,KAAKA,CAAAC,IAAA,EAMoF;EAAA,IANnF;IACf;AACA;AACA;AACA;AACA;IACAC,SAAS,GAAG,CAAC,CAAC,CAAC;IAAEC,QAAQ,GAAG,CAAC;IAAEC,KAAK,GAAG,GAAG;IAAEC,YAAY,GAAG,GAAG;IAAEC,SAAS,GAAG,GAAG;IAAEC;EAAc,CAAC,GAAAN,IAAA;EAC5F,MAAMO,MAAM,GAAGN,SAAS,CAAC,CAAC,CAAC;EAC3B;AACJ;AACA;AACA;EACI,MAAMO,KAAK,GAAG;IAAEC,IAAI,EAAE,KAAK;IAAEC,KAAK,EAAEH;EAAO,CAAC;EAC5C,IAAII,SAAS,GAAGR,KAAK,GAAGD,QAAQ;EAChC,MAAMU,KAAK,GAAGL,MAAM,GAAGI,SAAS;EAChC,MAAME,MAAM,GAAGP,YAAY,KAAKQ,SAAS,GAAGF,KAAK,GAAGN,YAAY,CAACM,KAAK,CAAC;EACvE;AACJ;AACA;AACA;EACI,IAAIC,MAAM,KAAKD,KAAK,EAChBD,SAAS,GAAGE,MAAM,GAAGN,MAAM;EAC/B,OAAO;IACHQ,IAAI,EAAGC,CAAC,IAAK;MACT,MAAMC,KAAK,GAAG,CAACN,SAAS,GAAGO,IAAI,CAACC,GAAG,CAAC,CAACH,CAAC,GAAGZ,YAAY,CAAC;MACtDI,KAAK,CAACC,IAAI,GAAG,EAAEQ,KAAK,GAAGZ,SAAS,IAAIY,KAAK,GAAG,CAACZ,SAAS,CAAC;MACvDG,KAAK,CAACE,KAAK,GAAGF,KAAK,CAACC,IAAI,GAAGI,MAAM,GAAGA,MAAM,GAAGI,KAAK;MAClD,OAAOT,KAAK;IAChB,CAAC;IACDY,UAAU,EAAEA,CAAA,KAAM,CAAE;EACxB,CAAC;AACL;AAEA,SAASrB,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}