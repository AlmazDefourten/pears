{"ast":null,"code":"import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nconst types = {\n  decay,\n  keyframes: keyframes,\n  tween: keyframes,\n  spring\n};\nfunction loopElapsed(elapsed, duration) {\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed) {\n  let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let isForwardPlayback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = update => {\n  const passTimestamp = _ref => {\n    let {\n      delta\n    } = _ref;\n    return update(delta);\n  };\n  return {\n    start: () => sync.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\nfunction animate(_ref2) {\n  let {\n    duration,\n    driver = framesync,\n    elapsed = 0,\n    repeat: repeatMax = 0,\n    repeatType = \"loop\",\n    repeatDelay = 0,\n    keyframes: keyframes$1,\n    autoplay = true,\n    onPlay,\n    onStop,\n    onComplete,\n    onRepeat,\n    onUpdate,\n    type = \"keyframes\",\n    ...options\n  } = _ref2;\n  var _a, _b;\n  const initialElapsed = elapsed;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = duration;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n  const origin = keyframes$1[0];\n  const target = keyframes$1[keyframes$1.length - 1];\n  let state = {\n    done: false,\n    value: origin\n  };\n  if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n    interpolateFromNumber = interpolate([0, 100], [origin, target], {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  const animation = animator({\n    ...options,\n    duration,\n    keyframes: keyframes$1\n  });\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls && driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      state = animation.next(Math.max(0, elapsed));\n      if (interpolateFromNumber) state.value = interpolateFromNumber(state.value);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate && onUpdate(state.value);\n    if (isComplete) {\n      if (repeatCount === 0) {\n        computedDuration = computedDuration !== undefined ? computedDuration : elapsed;\n      }\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay && onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop && onStop();\n      driverControls && driverControls.stop();\n    },\n    /**\r\n     * Set the current time of the animation. This is purposefully\r\n     * mirroring the WAAPI animation API to make them interchanagable.\r\n     * Going forward this file should be ported more towards\r\n     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\r\n     * Which behaviourally adheres to WAAPI as far as possible.\r\n     *\r\n     * WARNING: This is not safe to use for most animations. We currently\r\n     * only use it for handoff from WAAPI within Framer.\r\n     *\r\n     * This animation function consumes time every frame rather than being sampled for time.\r\n     * So the sample() method performs some headless frames to ensure\r\n     * repeats are handled correctly. Ideally in the future we will replace\r\n     * that method with this, once repeat calculations are pure.\r\n     */\n    set currentTime(t) {\n      elapsed = initialElapsed;\n      update(t);\n    },\n    /**\r\n     * animate() can't yet be sampled for time, instead it\r\n     * consumes time. So to sample it we have to run a low\r\n     * temporal-resolution version.\r\n     */\n    sample: t => {\n      elapsed = initialElapsed;\n      const sampleResolution = duration && typeof duration === \"number\" ? Math.max(duration * 0.5, 50) : 50;\n      let sampleElapsed = 0;\n      update(0);\n      while (sampleElapsed <= t) {\n        const remaining = t - sampleElapsed;\n        update(Math.min(remaining, sampleResolution));\n        sampleElapsed += sampleResolution;\n      }\n      return state;\n    }\n  };\n}\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };","map":{"version":3,"names":["keyframes","spring","decay","sync","cancelSync","interpolate","types","tween","loopElapsed","elapsed","duration","delay","arguments","length","undefined","reverseElapsed","isForwardPlayback","hasRepeatDelayElapsed","framesync","update","passTimestamp","_ref","delta","start","stop","animate","_ref2","driver","repeat","repeatMax","repeatType","repeatDelay","keyframes$1","autoplay","onPlay","onStop","onComplete","onRepeat","onUpdate","type","options","_a","_b","initialElapsed","driverControls","repeatCount","computedDuration","isComplete","interpolateFromNumber","animator","origin","target","state","done","value","needsInterpolation","call","clamp","animation","flipTarget","complete","next","Math","max","play","currentTime","t","sample","sampleResolution","sampleElapsed","remaining","min"],"sources":["C:/Users/Кирилл/Desktop/here/pears/frontend/node_modules/framer-motion/dist/es/animation/legacy-popmotion/index.mjs"],"sourcesContent":["import { keyframes } from './keyframes.mjs';\r\nimport { spring } from './spring.mjs';\r\nimport { decay } from './decay.mjs';\r\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\r\nimport { interpolate } from '../../utils/interpolate.mjs';\r\n\r\nconst types = {\r\n    decay,\r\n    keyframes: keyframes,\r\n    tween: keyframes,\r\n    spring,\r\n};\r\nfunction loopElapsed(elapsed, duration, delay = 0) {\r\n    return elapsed - duration - delay;\r\n}\r\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\r\n    return isForwardPlayback\r\n        ? loopElapsed(duration + -elapsed, duration, delay)\r\n        : duration - (elapsed - duration) + delay;\r\n}\r\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\r\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\r\n}\r\nconst framesync = (update) => {\r\n    const passTimestamp = ({ delta }) => update(delta);\r\n    return {\r\n        start: () => sync.update(passTimestamp, true),\r\n        stop: () => cancelSync.update(passTimestamp),\r\n    };\r\n};\r\nfunction animate({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, keyframes: keyframes$1, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type = \"keyframes\", ...options }) {\r\n    var _a, _b;\r\n    const initialElapsed = elapsed;\r\n    let driverControls;\r\n    let repeatCount = 0;\r\n    let computedDuration = duration;\r\n    let isComplete = false;\r\n    let isForwardPlayback = true;\r\n    let interpolateFromNumber;\r\n    const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\r\n    const origin = keyframes$1[0];\r\n    const target = keyframes$1[keyframes$1.length - 1];\r\n    let state = { done: false, value: origin };\r\n    if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\r\n        interpolateFromNumber = interpolate([0, 100], [origin, target], {\r\n            clamp: false,\r\n        });\r\n        keyframes$1 = [0, 100];\r\n    }\r\n    const animation = animator({\r\n        ...options,\r\n        duration,\r\n        keyframes: keyframes$1,\r\n    });\r\n    function repeat() {\r\n        repeatCount++;\r\n        if (repeatType === \"reverse\") {\r\n            isForwardPlayback = repeatCount % 2 === 0;\r\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\r\n        }\r\n        else {\r\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\r\n            if (repeatType === \"mirror\")\r\n                animation.flipTarget();\r\n        }\r\n        isComplete = false;\r\n        onRepeat && onRepeat();\r\n    }\r\n    function complete() {\r\n        driverControls && driverControls.stop();\r\n        onComplete && onComplete();\r\n    }\r\n    function update(delta) {\r\n        if (!isForwardPlayback)\r\n            delta = -delta;\r\n        elapsed += delta;\r\n        if (!isComplete) {\r\n            state = animation.next(Math.max(0, elapsed));\r\n            if (interpolateFromNumber)\r\n                state.value = interpolateFromNumber(state.value);\r\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\r\n        }\r\n        onUpdate && onUpdate(state.value);\r\n        if (isComplete) {\r\n            if (repeatCount === 0) {\r\n                computedDuration =\r\n                    computedDuration !== undefined ? computedDuration : elapsed;\r\n            }\r\n            if (repeatCount < repeatMax) {\r\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\r\n            }\r\n            else {\r\n                complete();\r\n            }\r\n        }\r\n    }\r\n    function play() {\r\n        onPlay && onPlay();\r\n        driverControls = driver(update);\r\n        driverControls.start();\r\n    }\r\n    autoplay && play();\r\n    return {\r\n        stop: () => {\r\n            onStop && onStop();\r\n            driverControls && driverControls.stop();\r\n        },\r\n        /**\r\n         * Set the current time of the animation. This is purposefully\r\n         * mirroring the WAAPI animation API to make them interchanagable.\r\n         * Going forward this file should be ported more towards\r\n         * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\r\n         * Which behaviourally adheres to WAAPI as far as possible.\r\n         *\r\n         * WARNING: This is not safe to use for most animations. We currently\r\n         * only use it for handoff from WAAPI within Framer.\r\n         *\r\n         * This animation function consumes time every frame rather than being sampled for time.\r\n         * So the sample() method performs some headless frames to ensure\r\n         * repeats are handled correctly. Ideally in the future we will replace\r\n         * that method with this, once repeat calculations are pure.\r\n         */\r\n        set currentTime(t) {\r\n            elapsed = initialElapsed;\r\n            update(t);\r\n        },\r\n        /**\r\n         * animate() can't yet be sampled for time, instead it\r\n         * consumes time. So to sample it we have to run a low\r\n         * temporal-resolution version.\r\n         */\r\n        sample: (t) => {\r\n            elapsed = initialElapsed;\r\n            const sampleResolution = duration && typeof duration === \"number\"\r\n                ? Math.max(duration * 0.5, 50)\r\n                : 50;\r\n            let sampleElapsed = 0;\r\n            update(0);\r\n            while (sampleElapsed <= t) {\r\n                const remaining = t - sampleElapsed;\r\n                update(Math.min(remaining, sampleResolution));\r\n                sampleElapsed += sampleResolution;\r\n            }\r\n            return state;\r\n        },\r\n    };\r\n}\r\n\r\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}