{"ast":null,"code":"import { px } from '../../value/types/numbers/units.mjs';\nfunction pixelsToPercent(pixels, axis) {\n  if (axis.max === axis.min) return 0;\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\nconst correctBorderRadius = {\n  correct: (latest, node) => {\n    if (!node.target) return latest;\n    /**\r\n     * If latest is a string, if it's a percentage we can return immediately as it's\r\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n     */\n    if (typeof latest === \"string\") {\n      if (px.test(latest)) {\n        latest = parseFloat(latest);\n      } else {\n        return latest;\n      }\n    }\n    /**\r\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n     * pixel value as a percentage of each axis\r\n     */\n    const x = pixelsToPercent(latest, node.target.x);\n    const y = pixelsToPercent(latest, node.target.y);\n    return `${x}% ${y}%`;\n  }\n};\nexport { correctBorderRadius, pixelsToPercent };","map":{"version":3,"names":["px","pixelsToPercent","pixels","axis","max","min","correctBorderRadius","correct","latest","node","target","test","parseFloat","x","y"],"sources":["C:/Users/Кирилл/Desktop/gdfjtgj/pears/frontend/node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs"],"sourcesContent":["import { px } from '../../value/types/numbers/units.mjs';\r\n\r\nfunction pixelsToPercent(pixels, axis) {\r\n    if (axis.max === axis.min)\r\n        return 0;\r\n    return (pixels / (axis.max - axis.min)) * 100;\r\n}\r\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\r\nconst correctBorderRadius = {\r\n    correct: (latest, node) => {\r\n        if (!node.target)\r\n            return latest;\r\n        /**\r\n         * If latest is a string, if it's a percentage we can return immediately as it's\r\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n         */\r\n        if (typeof latest === \"string\") {\r\n            if (px.test(latest)) {\r\n                latest = parseFloat(latest);\r\n            }\r\n            else {\r\n                return latest;\r\n            }\r\n        }\r\n        /**\r\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n         * pixel value as a percentage of each axis\r\n         */\r\n        const x = pixelsToPercent(latest, node.target.x);\r\n        const y = pixelsToPercent(latest, node.target.y);\r\n        return `${x}% ${y}%`;\r\n    },\r\n};\r\n\r\nexport { correctBorderRadius, pixelsToPercent };\r\n"],"mappings":"AAAA,SAASA,EAAE,QAAQ,qCAAqC;AAExD,SAASC,eAAeA,CAACC,MAAM,EAAEC,IAAI,EAAE;EACnC,IAAIA,IAAI,CAACC,GAAG,KAAKD,IAAI,CAACE,GAAG,EACrB,OAAO,CAAC;EACZ,OAAQH,MAAM,IAAIC,IAAI,CAACC,GAAG,GAAGD,IAAI,CAACE,GAAG,CAAC,GAAI,GAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,GAAG;EACxBC,OAAO,EAAEA,CAACC,MAAM,EAAEC,IAAI,KAAK;IACvB,IAAI,CAACA,IAAI,CAACC,MAAM,EACZ,OAAOF,MAAM;IACjB;AACR;AACA;AACA;IACQ,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;MAC5B,IAAIR,EAAE,CAACW,IAAI,CAACH,MAAM,CAAC,EAAE;QACjBA,MAAM,GAAGI,UAAU,CAACJ,MAAM,CAAC;MAC/B,CAAC,MACI;QACD,OAAOA,MAAM;MACjB;IACJ;IACA;AACR;AACA;AACA;IACQ,MAAMK,CAAC,GAAGZ,eAAe,CAACO,MAAM,EAAEC,IAAI,CAACC,MAAM,CAACG,CAAC,CAAC;IAChD,MAAMC,CAAC,GAAGb,eAAe,CAACO,MAAM,EAAEC,IAAI,CAACC,MAAM,CAACI,CAAC,CAAC;IAChD,OAAQ,GAAED,CAAE,KAAIC,CAAE,GAAE;EACxB;AACJ,CAAC;AAED,SAASR,mBAAmB,EAAEL,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}