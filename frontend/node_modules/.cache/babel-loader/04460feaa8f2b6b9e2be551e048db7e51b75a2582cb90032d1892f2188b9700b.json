{"ast":null,"code":"import { resolveElements } from '../utils/resolve-elements.es.js';\nimport { isFunction } from '@motionone/utils';\nconst thresholds = {\n  any: 0,\n  all: 1\n};\nfunction inView(elementOrSelector, onStart) {\n  let {\n    root,\n    margin: rootMargin,\n    amount = \"any\"\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  /**\r\n   * If this browser doesn't support IntersectionObserver, return a dummy stop function.\r\n   * Default triggering of onStart is tricky - it could be used for starting/stopping\r\n   * videos, lazy loading content etc. We could provide an option to enable a fallback, or\r\n   * provide a fallback callback option.\r\n   */\n  if (typeof IntersectionObserver === \"undefined\") {\n    return () => {};\n  }\n  const elements = resolveElements(elementOrSelector);\n  const activeIntersections = new WeakMap();\n  const onIntersectionChange = entries => {\n    entries.forEach(entry => {\n      const onEnd = activeIntersections.get(entry.target);\n      /**\r\n       * If there's no change to the intersection, we don't need to\r\n       * do anything here.\r\n       */\n      if (entry.isIntersecting === Boolean(onEnd)) return;\n      if (entry.isIntersecting) {\n        const newOnEnd = onStart(entry);\n        if (isFunction(newOnEnd)) {\n          activeIntersections.set(entry.target, newOnEnd);\n        } else {\n          observer.unobserve(entry.target);\n        }\n      } else if (onEnd) {\n        onEnd(entry);\n        activeIntersections.delete(entry.target);\n      }\n    });\n  };\n  const observer = new IntersectionObserver(onIntersectionChange, {\n    root,\n    rootMargin,\n    threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n  });\n  elements.forEach(element => observer.observe(element));\n  return () => observer.disconnect();\n}\nexport { inView };","map":{"version":3,"names":["resolveElements","isFunction","thresholds","any","all","inView","elementOrSelector","onStart","root","margin","rootMargin","amount","arguments","length","undefined","IntersectionObserver","elements","activeIntersections","WeakMap","onIntersectionChange","entries","forEach","entry","onEnd","get","target","isIntersecting","Boolean","newOnEnd","set","observer","unobserve","delete","threshold","element","observe","disconnect"],"sources":["C:/Users/Кирилл/Desktop/gdfjtgj/pears/frontend/node_modules/@motionone/dom/dist/gestures/in-view.es.js"],"sourcesContent":["import { resolveElements } from '../utils/resolve-elements.es.js';\r\nimport { isFunction } from '@motionone/utils';\r\n\r\nconst thresholds = {\r\n    any: 0,\r\n    all: 1,\r\n};\r\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"any\" } = {}) {\r\n    /**\r\n     * If this browser doesn't support IntersectionObserver, return a dummy stop function.\r\n     * Default triggering of onStart is tricky - it could be used for starting/stopping\r\n     * videos, lazy loading content etc. We could provide an option to enable a fallback, or\r\n     * provide a fallback callback option.\r\n     */\r\n    if (typeof IntersectionObserver === \"undefined\") {\r\n        return () => { };\r\n    }\r\n    const elements = resolveElements(elementOrSelector);\r\n    const activeIntersections = new WeakMap();\r\n    const onIntersectionChange = (entries) => {\r\n        entries.forEach((entry) => {\r\n            const onEnd = activeIntersections.get(entry.target);\r\n            /**\r\n             * If there's no change to the intersection, we don't need to\r\n             * do anything here.\r\n             */\r\n            if (entry.isIntersecting === Boolean(onEnd))\r\n                return;\r\n            if (entry.isIntersecting) {\r\n                const newOnEnd = onStart(entry);\r\n                if (isFunction(newOnEnd)) {\r\n                    activeIntersections.set(entry.target, newOnEnd);\r\n                }\r\n                else {\r\n                    observer.unobserve(entry.target);\r\n                }\r\n            }\r\n            else if (onEnd) {\r\n                onEnd(entry);\r\n                activeIntersections.delete(entry.target);\r\n            }\r\n        });\r\n    };\r\n    const observer = new IntersectionObserver(onIntersectionChange, {\r\n        root,\r\n        rootMargin,\r\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\r\n    });\r\n    elements.forEach((element) => observer.observe(element));\r\n    return () => observer.disconnect();\r\n}\r\n\r\nexport { inView };\r\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,iCAAiC;AACjE,SAASC,UAAU,QAAQ,kBAAkB;AAE7C,MAAMC,UAAU,GAAG;EACfC,GAAG,EAAE,CAAC;EACNC,GAAG,EAAE;AACT,CAAC;AACD,SAASC,MAAMA,CAACC,iBAAiB,EAAEC,OAAO,EAAqD;EAAA,IAAnD;IAAEC,IAAI;IAAEC,MAAM,EAAEC,UAAU;IAAEC,MAAM,GAAG;EAAM,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACzF;AACJ;AACA;AACA;AACA;AACA;EACI,IAAI,OAAOG,oBAAoB,KAAK,WAAW,EAAE;IAC7C,OAAO,MAAM,CAAE,CAAC;EACpB;EACA,MAAMC,QAAQ,GAAGhB,eAAe,CAACM,iBAAiB,CAAC;EACnD,MAAMW,mBAAmB,GAAG,IAAIC,OAAO,EAAE;EACzC,MAAMC,oBAAoB,GAAIC,OAAO,IAAK;IACtCA,OAAO,CAACC,OAAO,CAAEC,KAAK,IAAK;MACvB,MAAMC,KAAK,GAAGN,mBAAmB,CAACO,GAAG,CAACF,KAAK,CAACG,MAAM,CAAC;MACnD;AACZ;AACA;AACA;MACY,IAAIH,KAAK,CAACI,cAAc,KAAKC,OAAO,CAACJ,KAAK,CAAC,EACvC;MACJ,IAAID,KAAK,CAACI,cAAc,EAAE;QACtB,MAAME,QAAQ,GAAGrB,OAAO,CAACe,KAAK,CAAC;QAC/B,IAAIrB,UAAU,CAAC2B,QAAQ,CAAC,EAAE;UACtBX,mBAAmB,CAACY,GAAG,CAACP,KAAK,CAACG,MAAM,EAAEG,QAAQ,CAAC;QACnD,CAAC,MACI;UACDE,QAAQ,CAACC,SAAS,CAACT,KAAK,CAACG,MAAM,CAAC;QACpC;MACJ,CAAC,MACI,IAAIF,KAAK,EAAE;QACZA,KAAK,CAACD,KAAK,CAAC;QACZL,mBAAmB,CAACe,MAAM,CAACV,KAAK,CAACG,MAAM,CAAC;MAC5C;IACJ,CAAC,CAAC;EACN,CAAC;EACD,MAAMK,QAAQ,GAAG,IAAIf,oBAAoB,CAACI,oBAAoB,EAAE;IAC5DX,IAAI;IACJE,UAAU;IACVuB,SAAS,EAAE,OAAOtB,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAGT,UAAU,CAACS,MAAM;EACtE,CAAC,CAAC;EACFK,QAAQ,CAACK,OAAO,CAAEa,OAAO,IAAKJ,QAAQ,CAACK,OAAO,CAACD,OAAO,CAAC,CAAC;EACxD,OAAO,MAAMJ,QAAQ,CAACM,UAAU,EAAE;AACtC;AAEA,SAAS/B,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}