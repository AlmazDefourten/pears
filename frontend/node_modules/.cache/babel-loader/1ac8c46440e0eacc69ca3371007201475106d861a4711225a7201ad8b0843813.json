{"ast":null,"code":"import { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from 'hey-listen';\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nimport { isBrowser } from '../../../utils/is-browser.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\nconst positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\nconst isPositionalKey = key => positionalKeys.has(key);\nconst hasPositionalKey = target => {\n  return Object.keys(target).some(isPositionalKey);\n};\nconst isNumOrPxType = v => v === number || v === px;\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, _ref) => {\n  let {\n    transform\n  } = _ref;\n  if (transform === \"none\" || !transform) return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  // Apply changes to element before measurement\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\nconst positionalValues = {\n  // Dimensions\n  width: (_ref2, _ref3) => {\n    let {\n      x\n    } = _ref2;\n    let {\n      paddingLeft = \"0\",\n      paddingRight = \"0\"\n    } = _ref3;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: (_ref4, _ref5) => {\n    let {\n      y\n    } = _ref4;\n    let {\n      paddingTop = \"0\",\n      paddingBottom = \"0\"\n    } = _ref5;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: (_bbox, _ref6) => {\n    let {\n      top\n    } = _ref6;\n    return parseFloat(top);\n  },\n  left: (_bbox, _ref7) => {\n    let {\n      left\n    } = _ref7;\n    return parseFloat(left);\n  },\n  bottom: (_ref8, _ref9) => {\n    let {\n      y\n    } = _ref8;\n    let {\n      top\n    } = _ref9;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: (_ref10, _ref11) => {\n    let {\n      x\n    } = _ref10;\n    let {\n      left\n    } = _ref11;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const {\n    display\n  } = elementComputedStyle;\n  const origin = {};\n  // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\r\n   * Record origins before we render and update styles\r\n   */\n  changedKeys.forEach(key => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(key => {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    const value = visualElement.getValue(key);\n    value && value.jump(origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nconst checkAndConvertChangedValueTypes = function (visualElement, target) {\n  let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let transitionEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  target = {\n    ...target\n  };\n  transitionEnd = {\n    ...transitionEnd\n  };\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType;\n    // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (let i = fromIndex; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        value.jump(to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    // If we removed transform values, reapply them before the next render\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(_ref12 => {\n        let [key, value] = _ref12;\n        visualElement.getValue(key).set(value);\n      });\n    }\n    // Reapply original values\n    visualElement.render();\n    // Restore scroll position\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({\n        top: scrollY\n      });\n    }\n    return {\n      target: convertedTarget,\n      transitionEnd\n    };\n  } else {\n    return {\n      target,\n      transitionEnd\n    };\n  }\n};\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target,\n    transitionEnd\n  };\n}\nexport { BoundingBoxDimension, positionalValues, unitConversion };","map":{"version":3,"names":["isKeyframesTarget","invariant","transformPropOrder","findDimensionValueType","isBrowser","number","px","positionalKeys","Set","isPositionalKey","key","has","hasPositionalKey","target","Object","keys","some","isNumOrPxType","v","BoundingBoxDimension","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","_ref","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","value","getValue","undefined","push","get","set","startsWith","length","render","positionalValues","width","_ref2","_ref3","x","paddingLeft","paddingRight","max","min","height","_ref4","_ref5","y","paddingTop","paddingBottom","top","_ref6","left","_ref7","bottom","_ref8","_ref9","right","_ref10","_ref11","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","element","current","elementComputedStyle","getComputedStyle","display","origin","setStaticValue","targetBbox","jump","checkAndConvertChangedValueTypes","arguments","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","hasValue","from","fromType","to","toType","numKeyframes","fromIndex","i","Array","isArray","map","scrollY","indexOf","window","pageYOffset","convertedTarget","_ref12","scrollTo","unitConversion"],"sources":["C:/Users/Кирилл/Desktop/here/pears/frontend/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"sourcesContent":["import { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\r\nimport { invariant } from 'hey-listen';\r\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\r\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\r\nimport { isBrowser } from '../../../utils/is-browser.mjs';\r\nimport { number } from '../../../value/types/numbers/index.mjs';\r\nimport { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nconst isPositionalKey = (key) => positionalKeys.has(key);\r\nconst hasPositionalKey = (target) => {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nconst isNumOrPxType = (v) => v === number || v === px;\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\r\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        const matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n};\r\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    const removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach((key) => {\r\n        const value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        visualElement.render();\r\n    return removedTransforms;\r\n}\r\nconst positionalValues = {\r\n    // Dimensions\r\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\r\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\r\n    top: (_bbox, { top }) => parseFloat(top),\r\n    left: (_bbox, { left }) => parseFloat(left),\r\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\r\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\r\n    const originBbox = visualElement.measureViewportBox();\r\n    const element = visualElement.current;\r\n    const elementComputedStyle = getComputedStyle(element);\r\n    const { display } = elementComputedStyle;\r\n    const origin = {};\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\r\n    }\r\n    /**\r\n     * Record origins before we render and update styles\r\n     */\r\n    changedKeys.forEach((key) => {\r\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\r\n    });\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    visualElement.render();\r\n    const targetBbox = visualElement.measureViewportBox();\r\n    changedKeys.forEach((key) => {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        const value = visualElement.getValue(key);\r\n        value && value.jump(origin[key]);\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\r\n    target = { ...target };\r\n    transitionEnd = { ...transitionEnd };\r\n    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    let removedTransformValues = [];\r\n    let hasAttemptedToRemoveTransformValues = false;\r\n    const changedValueTypeKeys = [];\r\n    targetPositionalKeys.forEach((key) => {\r\n        const value = visualElement.getValue(key);\r\n        if (!visualElement.hasValue(key))\r\n            return;\r\n        let from = origin[key];\r\n        let fromType = findDimensionValueType(from);\r\n        const to = target[key];\r\n        let toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            const numKeyframes = to.length;\r\n            const fromIndex = to[0] === null ? 1 : 0;\r\n            from = to[fromIndex];\r\n            fromType = findDimensionValueType(from);\r\n            for (let i = fromIndex; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = findDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = findDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                const current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\r\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\r\n                (from === 0 || to === 0)) {\r\n                // If one or the other value is 0, it's safe to coerce it to the\r\n                // type of the other without measurement\r\n                if (from === 0) {\r\n                    value.set(toType.transform(from));\r\n                }\r\n                else {\r\n                    target[key] = fromType.transform(to);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues =\r\n                        removeNonTranslationalTransform(visualElement);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                changedValueTypeKeys.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                value.jump(to);\r\n            }\r\n        }\r\n    });\r\n    if (changedValueTypeKeys.length) {\r\n        const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0\r\n            ? window.pageYOffset\r\n            : null;\r\n        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(([key, value]) => {\r\n                visualElement.getValue(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        visualElement.render();\r\n        // Restore scroll position\r\n        if (isBrowser && scrollY !== null) {\r\n            window.scrollTo({ top: scrollY });\r\n        }\r\n        return { target: convertedTarget, transitionEnd };\r\n    }\r\n    else {\r\n        return { target, transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\r\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\r\n        : { target, transitionEnd };\r\n}\r\n\r\nexport { BoundingBoxDimension, positionalValues, unitConversion };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}