{"ast":null,"code":"import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\nfunction handoffOptimizedAppearAnimation(id, name, value,\n/**\r\n * This function is loaded via window by startOptimisedAnimation.\r\n * By accepting `sync` as an argument, rather than using it via\r\n * import, it can be kept out of the first-load Framer bundle,\r\n * while also allowing this function to not be included in\r\n * Framer Motion bundles where it's not needed.\r\n */\nsync) {\n  const storeId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  const appearAnimation = appearAnimationStore.get(storeId);\n  if (!appearAnimation) return 0;\n  const {\n    animation,\n    startTime\n  } = appearAnimation;\n  const cancelOptimisedAnimation = () => {\n    appearAnimationStore.delete(storeId);\n    /**\r\n     * Animation.cancel() throws so it needs to be wrapped in a try/catch\r\n     */\n    try {\n      animation.cancel();\n    } catch (e) {}\n  };\n  if (startTime !== null) {\n    const sampledTime = performance.now();\n    /**\r\n     * Resync handoff animation with optimised animation.\r\n     *\r\n     * This step would be unnecessary if we triggered animateChanges() in useEffect,\r\n     * but due to potential hydration errors we currently fire them in useLayoutEffect.\r\n     *\r\n     * By the time we're safely ready to cancel the optimised WAAPI animation,\r\n     * the main thread might have been blocked and desynced the two animations.\r\n     *\r\n     * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\r\n     */\n    sync.update(() => {\n      if (value.animation) {\n        value.animation.currentTime = performance.now() - sampledTime;\n      }\n    });\n    /**\r\n     * We allow the animation to persist until the next frame:\r\n     *   1. So it continues to play until Framer Motion is ready to render\r\n     *      (avoiding a potential flash of the element's original state)\r\n     *   2. As all independent transforms share a single transform animation, stopping\r\n     *      it synchronously would prevent subsequent transforms from handing off.\r\n     */\n    sync.render(cancelOptimisedAnimation);\n    /**\r\n     * We use main thread timings vs those returned by Animation.currentTime as it\r\n     * can be the case, particularly in Firefox, that currentTime doesn't return\r\n     * an updated value for several frames, even as the animation plays smoothly via\r\n     * the GPU.\r\n     */\n    return sampledTime - startTime || 0;\n  } else {\n    cancelOptimisedAnimation();\n    return 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"names":["transformProps","appearAnimationStore","appearStoreId","handoffOptimizedAppearAnimation","id","name","value","sync","storeId","has","appearAnimation","get","animation","startTime","cancelOptimisedAnimation","delete","cancel","e","sampledTime","performance","now","update","currentTime","render"],"sources":["C:/Users/Кирилл/Desktop/gdfjtgj/pears/frontend/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"sourcesContent":["import { transformProps } from '../../render/html/utils/transform.mjs';\r\nimport { appearAnimationStore } from './store.mjs';\r\nimport { appearStoreId } from './store-id.mjs';\r\n\r\nfunction handoffOptimizedAppearAnimation(id, name, value, \r\n/**\r\n * This function is loaded via window by startOptimisedAnimation.\r\n * By accepting `sync` as an argument, rather than using it via\r\n * import, it can be kept out of the first-load Framer bundle,\r\n * while also allowing this function to not be included in\r\n * Framer Motion bundles where it's not needed.\r\n */\r\nsync) {\r\n    const storeId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\r\n    const appearAnimation = appearAnimationStore.get(storeId);\r\n    if (!appearAnimation)\r\n        return 0;\r\n    const { animation, startTime } = appearAnimation;\r\n    const cancelOptimisedAnimation = () => {\r\n        appearAnimationStore.delete(storeId);\r\n        /**\r\n         * Animation.cancel() throws so it needs to be wrapped in a try/catch\r\n         */\r\n        try {\r\n            animation.cancel();\r\n        }\r\n        catch (e) { }\r\n    };\r\n    if (startTime !== null) {\r\n        const sampledTime = performance.now();\r\n        /**\r\n         * Resync handoff animation with optimised animation.\r\n         *\r\n         * This step would be unnecessary if we triggered animateChanges() in useEffect,\r\n         * but due to potential hydration errors we currently fire them in useLayoutEffect.\r\n         *\r\n         * By the time we're safely ready to cancel the optimised WAAPI animation,\r\n         * the main thread might have been blocked and desynced the two animations.\r\n         *\r\n         * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\r\n         */\r\n        sync.update(() => {\r\n            if (value.animation) {\r\n                value.animation.currentTime = performance.now() - sampledTime;\r\n            }\r\n        });\r\n        /**\r\n         * We allow the animation to persist until the next frame:\r\n         *   1. So it continues to play until Framer Motion is ready to render\r\n         *      (avoiding a potential flash of the element's original state)\r\n         *   2. As all independent transforms share a single transform animation, stopping\r\n         *      it synchronously would prevent subsequent transforms from handing off.\r\n         */\r\n        sync.render(cancelOptimisedAnimation);\r\n        /**\r\n         * We use main thread timings vs those returned by Animation.currentTime as it\r\n         * can be the case, particularly in Firefox, that currentTime doesn't return\r\n         * an updated value for several frames, even as the animation plays smoothly via\r\n         * the GPU.\r\n         */\r\n        return sampledTime - startTime || 0;\r\n    }\r\n    else {\r\n        cancelOptimisedAnimation();\r\n        return 0;\r\n    }\r\n}\r\n\r\nexport { handoffOptimizedAppearAnimation };\r\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,uCAAuC;AACtE,SAASC,oBAAoB,QAAQ,aAAa;AAClD,SAASC,aAAa,QAAQ,gBAAgB;AAE9C,SAASC,+BAA+BA,CAACC,EAAE,EAAEC,IAAI,EAAEC,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,IAAI,EAAE;EACF,MAAMC,OAAO,GAAGN,aAAa,CAACE,EAAE,EAAEJ,cAAc,CAACS,GAAG,CAACJ,IAAI,CAAC,GAAG,WAAW,GAAGA,IAAI,CAAC;EAChF,MAAMK,eAAe,GAAGT,oBAAoB,CAACU,GAAG,CAACH,OAAO,CAAC;EACzD,IAAI,CAACE,eAAe,EAChB,OAAO,CAAC;EACZ,MAAM;IAAEE,SAAS;IAAEC;EAAU,CAAC,GAAGH,eAAe;EAChD,MAAMI,wBAAwB,GAAGA,CAAA,KAAM;IACnCb,oBAAoB,CAACc,MAAM,CAACP,OAAO,CAAC;IACpC;AACR;AACA;IACQ,IAAI;MACAI,SAAS,CAACI,MAAM,EAAE;IACtB,CAAC,CACD,OAAOC,CAAC,EAAE,CAAE;EAChB,CAAC;EACD,IAAIJ,SAAS,KAAK,IAAI,EAAE;IACpB,MAAMK,WAAW,GAAGC,WAAW,CAACC,GAAG,EAAE;IACrC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQb,IAAI,CAACc,MAAM,CAAC,MAAM;MACd,IAAIf,KAAK,CAACM,SAAS,EAAE;QACjBN,KAAK,CAACM,SAAS,CAACU,WAAW,GAAGH,WAAW,CAACC,GAAG,EAAE,GAAGF,WAAW;MACjE;IACJ,CAAC,CAAC;IACF;AACR;AACA;AACA;AACA;AACA;AACA;IACQX,IAAI,CAACgB,MAAM,CAACT,wBAAwB,CAAC;IACrC;AACR;AACA;AACA;AACA;AACA;IACQ,OAAOI,WAAW,GAAGL,SAAS,IAAI,CAAC;EACvC,CAAC,MACI;IACDC,wBAAwB,EAAE;IAC1B,OAAO,CAAC;EACZ;AACJ;AAEA,SAASX,+BAA+B"},"metadata":{},"sourceType":"module","externalDependencies":[]}