{"ast":null,"code":"import * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { useProjectionId } from '../projection/node/id.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { SwitchLayoutGroupContext } from '../context/SwitchLayoutGroupContext.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\n\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\nfunction createMotionComponent(_ref) {\n  let {\n    preloadedFeatures,\n    createVisualElement,\n    projectionNodeConstructor,\n    useRender,\n    useVisualState,\n    Component\n  } = _ref;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    const configAndProps = {\n      ...useContext(MotionConfigContext),\n      ...props,\n      layoutId: useLayoutId(props)\n    };\n    const {\n      isStatic\n    } = configAndProps;\n    let features = null;\n    const context = useCreateMotionContext(props);\n    /**\r\n     * Create a unique projection ID for this component. If a new component is added\r\n     * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\r\n     * us to measure it as soon as any layout effect flushes pending layout animations.\r\n     *\r\n     * Performance note: It'd be better not to have to search the DOM for these elements.\r\n     * For newly-entering components it could be enough to only correct treeScale, in which\r\n     * case we could mount in a scale-correction mode. This wouldn't be enough for\r\n     * shared element transitions however. Perhaps for those we could revert to a root node\r\n     * that gets forceRendered and layout animations are triggered on its layout effect.\r\n     */\n    const projectionId = isStatic ? undefined : useProjectionId();\n    /**\r\n     *\r\n     */\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      /**\r\n       * Create a VisualElement for this component. A VisualElement provides a common\r\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n       * providing a way of rendering to these APIs outside of the React render loop\r\n       * for more performant animations and interactions\r\n       */\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n      /**\r\n       * Load Motion gesture and animation features. These are rendered as renderless\r\n       * components so each feature can optionally make use of React lifecycle methods.\r\n       */\n      const lazyStrictMode = useContext(LazyContext).strict;\n      const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n      if (context.visualElement) {\n        features = context.visualElement.loadFeatures(\n        // Note: Pass the full new combined props to correctly re-render dynamic feature components.\n        configAndProps, lazyStrictMode, preloadedFeatures, projectionId, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor, initialLayoutGroupConfig);\n      }\n    }\n    /**\r\n     * The mount order and hierarchy is specific to ensure our element ref\r\n     * is hydrated by the time features fire their effects.\r\n     */\n    return React.createElement(VisualElementHandler, {\n      visualElement: context.visualElement,\n      props: configAndProps\n    }, features, React.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)));\n  }\n  const ForwardRefComponent = forwardRef(MotionComponent);\n  ForwardRefComponent[motionComponentSymbol] = Component;\n  return ForwardRefComponent;\n}\nfunction useLayoutId(_ref2) {\n  let {\n    layoutId\n  } = _ref2;\n  const layoutGroupId = useContext(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nexport { createMotionComponent };","map":{"version":3,"names":["React","forwardRef","useContext","MotionConfigContext","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","featureDefinitions","loadFeatures","isBrowser","useProjectionId","LayoutGroupContext","VisualElementHandler","LazyContext","SwitchLayoutGroupContext","motionComponentSymbol","createMotionComponent","_ref","preloadedFeatures","createVisualElement","projectionNodeConstructor","useRender","useVisualState","Component","MotionComponent","props","externalRef","configAndProps","layoutId","useLayoutId","isStatic","features","context","projectionId","undefined","visualState","visualElement","lazyStrictMode","strict","initialLayoutGroupConfig","createElement","Provider","value","ForwardRefComponent","_ref2","layoutGroupId","id"],"sources":["C:/Users/Кирилл/Desktop/gdfjtgj/pears/frontend/node_modules/framer-motion/dist/es/motion/index.mjs"],"sourcesContent":["import * as React from 'react';\r\nimport { forwardRef, useContext } from 'react';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\r\nimport { MotionContext } from '../context/MotionContext/index.mjs';\r\nimport { useVisualElement } from './utils/use-visual-element.mjs';\r\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\r\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\r\nimport { featureDefinitions } from './features/definitions.mjs';\r\nimport { loadFeatures } from './features/load-features.mjs';\r\nimport { isBrowser } from '../utils/is-browser.mjs';\r\nimport { useProjectionId } from '../projection/node/id.mjs';\r\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\r\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\r\nimport { LazyContext } from '../context/LazyContext.mjs';\r\nimport { SwitchLayoutGroupContext } from '../context/SwitchLayoutGroupContext.mjs';\r\nimport { motionComponentSymbol } from './utils/symbol.mjs';\r\n\r\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\r\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component, }) {\r\n    preloadedFeatures && loadFeatures(preloadedFeatures);\r\n    function MotionComponent(props, externalRef) {\r\n        const configAndProps = {\r\n            ...useContext(MotionConfigContext),\r\n            ...props,\r\n            layoutId: useLayoutId(props),\r\n        };\r\n        const { isStatic } = configAndProps;\r\n        let features = null;\r\n        const context = useCreateMotionContext(props);\r\n        /**\r\n         * Create a unique projection ID for this component. If a new component is added\r\n         * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\r\n         * us to measure it as soon as any layout effect flushes pending layout animations.\r\n         *\r\n         * Performance note: It'd be better not to have to search the DOM for these elements.\r\n         * For newly-entering components it could be enough to only correct treeScale, in which\r\n         * case we could mount in a scale-correction mode. This wouldn't be enough for\r\n         * shared element transitions however. Perhaps for those we could revert to a root node\r\n         * that gets forceRendered and layout animations are triggered on its layout effect.\r\n         */\r\n        const projectionId = isStatic ? undefined : useProjectionId();\r\n        /**\r\n         *\r\n         */\r\n        const visualState = useVisualState(props, isStatic);\r\n        if (!isStatic && isBrowser) {\r\n            /**\r\n             * Create a VisualElement for this component. A VisualElement provides a common\r\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n             * providing a way of rendering to these APIs outside of the React render loop\r\n             * for more performant animations and interactions\r\n             */\r\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\r\n            /**\r\n             * Load Motion gesture and animation features. These are rendered as renderless\r\n             * components so each feature can optionally make use of React lifecycle methods.\r\n             */\r\n            const lazyStrictMode = useContext(LazyContext).strict;\r\n            const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\r\n            if (context.visualElement) {\r\n                features = context.visualElement.loadFeatures(\r\n                // Note: Pass the full new combined props to correctly re-render dynamic feature components.\r\n                configAndProps, lazyStrictMode, preloadedFeatures, projectionId, projectionNodeConstructor ||\r\n                    featureDefinitions.projectionNodeConstructor, initialLayoutGroupConfig);\r\n            }\r\n        }\r\n        /**\r\n         * The mount order and hierarchy is specific to ensure our element ref\r\n         * is hydrated by the time features fire their effects.\r\n         */\r\n        return (React.createElement(VisualElementHandler, { visualElement: context.visualElement, props: configAndProps },\r\n            features,\r\n            React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))));\r\n    }\r\n    const ForwardRefComponent = forwardRef(MotionComponent);\r\n    ForwardRefComponent[motionComponentSymbol] = Component;\r\n    return ForwardRefComponent;\r\n}\r\nfunction useLayoutId({ layoutId }) {\r\n    const layoutGroupId = useContext(LayoutGroupContext).id;\r\n    return layoutGroupId && layoutId !== undefined\r\n        ? layoutGroupId + \"-\" + layoutId\r\n        : layoutId;\r\n}\r\n\r\nexport { createMotionComponent };\r\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,UAAU,EAAEC,UAAU,QAAQ,OAAO;AAC9C,SAASC,mBAAmB,QAAQ,oCAAoC;AACxE,SAASC,aAAa,QAAQ,oCAAoC;AAClE,SAASC,gBAAgB,QAAQ,gCAAgC;AACjE,SAASC,YAAY,QAAQ,4BAA4B;AACzD,SAASC,sBAAsB,QAAQ,qCAAqC;AAC5E,SAASC,kBAAkB,QAAQ,4BAA4B;AAC/D,SAASC,YAAY,QAAQ,8BAA8B;AAC3D,SAASC,SAAS,QAAQ,yBAAyB;AACnD,SAASC,eAAe,QAAQ,2BAA2B;AAC3D,SAASC,kBAAkB,QAAQ,mCAAmC;AACtE,SAASC,oBAAoB,QAAQ,kCAAkC;AACvE,SAASC,WAAW,QAAQ,4BAA4B;AACxD,SAASC,wBAAwB,QAAQ,yCAAyC;AAClF,SAASC,qBAAqB,QAAQ,oBAAoB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAAAC,IAAA,EAA+G;EAAA,IAA9G;IAAEC,iBAAiB;IAAEC,mBAAmB;IAAEC,yBAAyB;IAAEC,SAAS;IAAEC,cAAc;IAAEC;EAAW,CAAC,GAAAN,IAAA;EACvIC,iBAAiB,IAAIV,YAAY,CAACU,iBAAiB,CAAC;EACpD,SAASM,eAAeA,CAACC,KAAK,EAAEC,WAAW,EAAE;IACzC,MAAMC,cAAc,GAAG;MACnB,GAAG1B,UAAU,CAACC,mBAAmB,CAAC;MAClC,GAAGuB,KAAK;MACRG,QAAQ,EAAEC,WAAW,CAACJ,KAAK;IAC/B,CAAC;IACD,MAAM;MAAEK;IAAS,CAAC,GAAGH,cAAc;IACnC,IAAII,QAAQ,GAAG,IAAI;IACnB,MAAMC,OAAO,GAAG1B,sBAAsB,CAACmB,KAAK,CAAC;IAC7C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,MAAMQ,YAAY,GAAGH,QAAQ,GAAGI,SAAS,GAAGxB,eAAe,EAAE;IAC7D;AACR;AACA;IACQ,MAAMyB,WAAW,GAAGb,cAAc,CAACG,KAAK,EAAEK,QAAQ,CAAC;IACnD,IAAI,CAACA,QAAQ,IAAIrB,SAAS,EAAE;MACxB;AACZ;AACA;AACA;AACA;AACA;MACYuB,OAAO,CAACI,aAAa,GAAGhC,gBAAgB,CAACmB,SAAS,EAAEY,WAAW,EAAER,cAAc,EAAER,mBAAmB,CAAC;MACrG;AACZ;AACA;AACA;MACY,MAAMkB,cAAc,GAAGpC,UAAU,CAACY,WAAW,CAAC,CAACyB,MAAM;MACrD,MAAMC,wBAAwB,GAAGtC,UAAU,CAACa,wBAAwB,CAAC;MACrE,IAAIkB,OAAO,CAACI,aAAa,EAAE;QACvBL,QAAQ,GAAGC,OAAO,CAACI,aAAa,CAAC5B,YAAY;QAC7C;QACAmB,cAAc,EAAEU,cAAc,EAAEnB,iBAAiB,EAAEe,YAAY,EAAEb,yBAAyB,IACtFb,kBAAkB,CAACa,yBAAyB,EAAEmB,wBAAwB,CAAC;MAC/E;IACJ;IACA;AACR;AACA;AACA;IACQ,OAAQxC,KAAK,CAACyC,aAAa,CAAC5B,oBAAoB,EAAE;MAAEwB,aAAa,EAAEJ,OAAO,CAACI,aAAa;MAAEX,KAAK,EAAEE;IAAe,CAAC,EAC7GI,QAAQ,EACRhC,KAAK,CAACyC,aAAa,CAACrC,aAAa,CAACsC,QAAQ,EAAE;MAAEC,KAAK,EAAEV;IAAQ,CAAC,EAAEX,SAAS,CAACE,SAAS,EAAEE,KAAK,EAAEQ,YAAY,EAAE5B,YAAY,CAAC8B,WAAW,EAAEH,OAAO,CAACI,aAAa,EAAEV,WAAW,CAAC,EAAES,WAAW,EAAEL,QAAQ,EAAEE,OAAO,CAACI,aAAa,CAAC,CAAC,CAAC;EAChO;EACA,MAAMO,mBAAmB,GAAG3C,UAAU,CAACwB,eAAe,CAAC;EACvDmB,mBAAmB,CAAC5B,qBAAqB,CAAC,GAAGQ,SAAS;EACtD,OAAOoB,mBAAmB;AAC9B;AACA,SAASd,WAAWA,CAAAe,KAAA,EAAe;EAAA,IAAd;IAAEhB;EAAS,CAAC,GAAAgB,KAAA;EAC7B,MAAMC,aAAa,GAAG5C,UAAU,CAACU,kBAAkB,CAAC,CAACmC,EAAE;EACvD,OAAOD,aAAa,IAAIjB,QAAQ,KAAKM,SAAS,GACxCW,aAAa,GAAG,GAAG,GAAGjB,QAAQ,GAC9BA,QAAQ;AAClB;AAEA,SAASZ,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}