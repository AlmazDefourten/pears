{"ast":null,"code":"import { sync } from '../../../frameloop/index.mjs';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\nclass MeasureLayoutWithContext extends React__default.Component {\n  /**\r\n   * This only mounts projection nodes for components that\r\n   * need measuring, we might want to do it for all components\r\n   * in order to incorporate transforms\r\n   */\n  componentDidMount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup,\n      layoutId\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n    if (projection) {\n      if (layoutGroup.group) layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions({\n        ...projection.options,\n        onExitComplete: () => this.safeToRemove()\n      });\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const {\n      layoutDependency,\n      visualElement,\n      drag,\n      isPresent\n    } = this.props;\n    const projection = visualElement.projection;\n    if (!projection) return null;\n    /**\r\n     * TODO: We use this data in relegate to determine whether to\r\n     * promote a previous element. There's no guarantee its presence data\r\n     * will have updated by this point - if a bug like this arises it will\r\n     * have to be that we markForRelegation and then find a new lead some other way,\r\n     * perhaps in didUpdate\r\n     */\n    projection.isPresent = isPresent;\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\r\n         * If there's another stack member taking over from this one,\r\n         * it's in charge of the exit animation and therefore should\r\n         * be in charge of the safe to remove. Otherwise we call it here.\r\n         */\n        sync.postRender(() => {\n          var _a;\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const {\n      projection\n    } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n  componentWillUnmount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup: promoteContext\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const {\n      safeToRemove\n    } = this.props;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n  render() {\n    return null;\n  }\n}\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = useContext(LayoutGroupContext);\n  return React__default.createElement(MeasureLayoutWithContext, {\n    ...props,\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  });\n}\nconst defaultScaleCorrectors = {\n  borderRadius: {\n    ...correctBorderRadius,\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  },\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\nexport { MeasureLayout };","map":{"version":3,"names":["sync","React__default","useContext","usePresence","LayoutGroupContext","SwitchLayoutGroupContext","globalProjectionState","correctBorderRadius","correctBoxShadow","addScaleCorrector","MeasureLayoutWithContext","Component","componentDidMount","visualElement","layoutGroup","switchLayoutGroup","layoutId","props","projection","defaultScaleCorrectors","group","add","register","root","didUpdate","addEventListener","safeToRemove","setOptions","options","onExitComplete","hasEverUpdated","getSnapshotBeforeUpdate","prevProps","layoutDependency","drag","isPresent","undefined","willUpdate","promote","relegate","postRender","_a","getStack","members","length","componentDidUpdate","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","MeasureLayout","createElement","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"sources":["C:/Users/Кирилл/Desktop/here/pears/frontend/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"],"sourcesContent":["import { sync } from '../../../frameloop/index.mjs';\r\nimport React__default, { useContext } from 'react';\r\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\r\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\r\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\r\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\r\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\r\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\r\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\r\n\r\nclass MeasureLayoutWithContext extends React__default.Component {\r\n    /**\r\n     * This only mounts projection nodes for components that\r\n     * need measuring, we might want to do it for all components\r\n     * in order to incorporate transforms\r\n     */\r\n    componentDidMount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\r\n        const { projection } = visualElement;\r\n        addScaleCorrector(defaultScaleCorrectors);\r\n        if (projection) {\r\n            if (layoutGroup.group)\r\n                layoutGroup.group.add(projection);\r\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\r\n                switchLayoutGroup.register(projection);\r\n            }\r\n            projection.root.didUpdate();\r\n            projection.addEventListener(\"animationComplete\", () => {\r\n                this.safeToRemove();\r\n            });\r\n            projection.setOptions({\r\n                ...projection.options,\r\n                onExitComplete: () => this.safeToRemove(),\r\n            });\r\n        }\r\n        globalProjectionState.hasEverUpdated = true;\r\n    }\r\n    getSnapshotBeforeUpdate(prevProps) {\r\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\r\n        const projection = visualElement.projection;\r\n        if (!projection)\r\n            return null;\r\n        /**\r\n         * TODO: We use this data in relegate to determine whether to\r\n         * promote a previous element. There's no guarantee its presence data\r\n         * will have updated by this point - if a bug like this arises it will\r\n         * have to be that we markForRelegation and then find a new lead some other way,\r\n         * perhaps in didUpdate\r\n         */\r\n        projection.isPresent = isPresent;\r\n        if (drag ||\r\n            prevProps.layoutDependency !== layoutDependency ||\r\n            layoutDependency === undefined) {\r\n            projection.willUpdate();\r\n        }\r\n        else {\r\n            this.safeToRemove();\r\n        }\r\n        if (prevProps.isPresent !== isPresent) {\r\n            if (isPresent) {\r\n                projection.promote();\r\n            }\r\n            else if (!projection.relegate()) {\r\n                /**\r\n                 * If there's another stack member taking over from this one,\r\n                 * it's in charge of the exit animation and therefore should\r\n                 * be in charge of the safe to remove. Otherwise we call it here.\r\n                 */\r\n                sync.postRender(() => {\r\n                    var _a;\r\n                    if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\r\n                        this.safeToRemove();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    componentDidUpdate() {\r\n        const { projection } = this.props.visualElement;\r\n        if (projection) {\r\n            projection.root.didUpdate();\r\n            if (!projection.currentAnimation && projection.isLead()) {\r\n                this.safeToRemove();\r\n            }\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\r\n        const { projection } = visualElement;\r\n        if (projection) {\r\n            projection.scheduleCheckAfterUnmount();\r\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\r\n                layoutGroup.group.remove(projection);\r\n            if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\r\n                promoteContext.deregister(projection);\r\n        }\r\n    }\r\n    safeToRemove() {\r\n        const { safeToRemove } = this.props;\r\n        safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\r\n    }\r\n    render() {\r\n        return null;\r\n    }\r\n}\r\nfunction MeasureLayout(props) {\r\n    const [isPresent, safeToRemove] = usePresence();\r\n    const layoutGroup = useContext(LayoutGroupContext);\r\n    return (React__default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\r\n}\r\nconst defaultScaleCorrectors = {\r\n    borderRadius: {\r\n        ...correctBorderRadius,\r\n        applyTo: [\r\n            \"borderTopLeftRadius\",\r\n            \"borderTopRightRadius\",\r\n            \"borderBottomLeftRadius\",\r\n            \"borderBottomRightRadius\",\r\n        ],\r\n    },\r\n    borderTopLeftRadius: correctBorderRadius,\r\n    borderTopRightRadius: correctBorderRadius,\r\n    borderBottomLeftRadius: correctBorderRadius,\r\n    borderBottomRightRadius: correctBorderRadius,\r\n    boxShadow: correctBoxShadow,\r\n};\r\n\r\nexport { MeasureLayout };\r\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,8BAA8B;AACnD,OAAOC,cAAc,IAAIC,UAAU,QAAQ,OAAO;AAClD,SAASC,WAAW,QAAQ,sDAAsD;AAClF,SAASC,kBAAkB,QAAQ,yCAAyC;AAC5E,SAASC,wBAAwB,QAAQ,+CAA+C;AACxF,SAASC,qBAAqB,QAAQ,oCAAoC;AAC1E,SAASC,mBAAmB,QAAQ,oDAAoD;AACxF,SAASC,gBAAgB,QAAQ,iDAAiD;AAClF,SAASC,iBAAiB,QAAQ,iDAAiD;AAEnF,MAAMC,wBAAwB,SAAST,cAAc,CAACU,SAAS,CAAC;EAC5D;AACJ;AACA;AACA;AACA;EACIC,iBAAiBA,CAAA,EAAG;IAChB,MAAM;MAAEC,aAAa;MAAEC,WAAW;MAAEC,iBAAiB;MAAEC;IAAS,CAAC,GAAG,IAAI,CAACC,KAAK;IAC9E,MAAM;MAAEC;IAAW,CAAC,GAAGL,aAAa;IACpCJ,iBAAiB,CAACU,sBAAsB,CAAC;IACzC,IAAID,UAAU,EAAE;MACZ,IAAIJ,WAAW,CAACM,KAAK,EACjBN,WAAW,CAACM,KAAK,CAACC,GAAG,CAACH,UAAU,CAAC;MACrC,IAAIH,iBAAiB,IAAIA,iBAAiB,CAACO,QAAQ,IAAIN,QAAQ,EAAE;QAC7DD,iBAAiB,CAACO,QAAQ,CAACJ,UAAU,CAAC;MAC1C;MACAA,UAAU,CAACK,IAAI,CAACC,SAAS,EAAE;MAC3BN,UAAU,CAACO,gBAAgB,CAAC,mBAAmB,EAAE,MAAM;QACnD,IAAI,CAACC,YAAY,EAAE;MACvB,CAAC,CAAC;MACFR,UAAU,CAACS,UAAU,CAAC;QAClB,GAAGT,UAAU,CAACU,OAAO;QACrBC,cAAc,EAAEA,CAAA,KAAM,IAAI,CAACH,YAAY;MAC3C,CAAC,CAAC;IACN;IACApB,qBAAqB,CAACwB,cAAc,GAAG,IAAI;EAC/C;EACAC,uBAAuBA,CAACC,SAAS,EAAE;IAC/B,MAAM;MAAEC,gBAAgB;MAAEpB,aAAa;MAAEqB,IAAI;MAAEC;IAAU,CAAC,GAAG,IAAI,CAAClB,KAAK;IACvE,MAAMC,UAAU,GAAGL,aAAa,CAACK,UAAU;IAC3C,IAAI,CAACA,UAAU,EACX,OAAO,IAAI;IACf;AACR;AACA;AACA;AACA;AACA;AACA;IACQA,UAAU,CAACiB,SAAS,GAAGA,SAAS;IAChC,IAAID,IAAI,IACJF,SAAS,CAACC,gBAAgB,KAAKA,gBAAgB,IAC/CA,gBAAgB,KAAKG,SAAS,EAAE;MAChClB,UAAU,CAACmB,UAAU,EAAE;IAC3B,CAAC,MACI;MACD,IAAI,CAACX,YAAY,EAAE;IACvB;IACA,IAAIM,SAAS,CAACG,SAAS,KAAKA,SAAS,EAAE;MACnC,IAAIA,SAAS,EAAE;QACXjB,UAAU,CAACoB,OAAO,EAAE;MACxB,CAAC,MACI,IAAI,CAACpB,UAAU,CAACqB,QAAQ,EAAE,EAAE;QAC7B;AAChB;AACA;AACA;AACA;QACgBvC,IAAI,CAACwC,UAAU,CAAC,MAAM;UAClB,IAAIC,EAAE;UACN,IAAI,EAAE,CAACA,EAAE,GAAGvB,UAAU,CAACwB,QAAQ,EAAE,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,OAAO,CAACC,MAAM,CAAC,EAAE;YACxF,IAAI,CAAClB,YAAY,EAAE;UACvB;QACJ,CAAC,CAAC;MACN;IACJ;IACA,OAAO,IAAI;EACf;EACAmB,kBAAkBA,CAAA,EAAG;IACjB,MAAM;MAAE3B;IAAW,CAAC,GAAG,IAAI,CAACD,KAAK,CAACJ,aAAa;IAC/C,IAAIK,UAAU,EAAE;MACZA,UAAU,CAACK,IAAI,CAACC,SAAS,EAAE;MAC3B,IAAI,CAACN,UAAU,CAAC4B,gBAAgB,IAAI5B,UAAU,CAAC6B,MAAM,EAAE,EAAE;QACrD,IAAI,CAACrB,YAAY,EAAE;MACvB;IACJ;EACJ;EACAsB,oBAAoBA,CAAA,EAAG;IACnB,MAAM;MAAEnC,aAAa;MAAEC,WAAW;MAAEC,iBAAiB,EAAEkC;IAAgB,CAAC,GAAG,IAAI,CAAChC,KAAK;IACrF,MAAM;MAAEC;IAAW,CAAC,GAAGL,aAAa;IACpC,IAAIK,UAAU,EAAE;MACZA,UAAU,CAACgC,yBAAyB,EAAE;MACtC,IAAIpC,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACM,KAAK,EAC3EN,WAAW,CAACM,KAAK,CAAC+B,MAAM,CAACjC,UAAU,CAAC;MACxC,IAAI+B,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,cAAc,CAACG,UAAU,EACzFH,cAAc,CAACG,UAAU,CAAClC,UAAU,CAAC;IAC7C;EACJ;EACAQ,YAAYA,CAAA,EAAG;IACX,MAAM;MAAEA;IAAa,CAAC,GAAG,IAAI,CAACT,KAAK;IACnCS,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,EAAE;EAC9E;EACA2B,MAAMA,CAAA,EAAG;IACL,OAAO,IAAI;EACf;AACJ;AACA,SAASC,aAAaA,CAACrC,KAAK,EAAE;EAC1B,MAAM,CAACkB,SAAS,EAAET,YAAY,CAAC,GAAGvB,WAAW,EAAE;EAC/C,MAAMW,WAAW,GAAGZ,UAAU,CAACE,kBAAkB,CAAC;EAClD,OAAQH,cAAc,CAACsD,aAAa,CAAC7C,wBAAwB,EAAE;IAAE,GAAGO,KAAK;IAAEH,WAAW,EAAEA,WAAW;IAAEC,iBAAiB,EAAEb,UAAU,CAACG,wBAAwB,CAAC;IAAE8B,SAAS,EAAEA,SAAS;IAAET,YAAY,EAAEA;EAAa,CAAC,CAAC;AACrN;AACA,MAAMP,sBAAsB,GAAG;EAC3BqC,YAAY,EAAE;IACV,GAAGjD,mBAAmB;IACtBkD,OAAO,EAAE,CACL,qBAAqB,EACrB,sBAAsB,EACtB,wBAAwB,EACxB,yBAAyB;EAEjC,CAAC;EACDC,mBAAmB,EAAEnD,mBAAmB;EACxCoD,oBAAoB,EAAEpD,mBAAmB;EACzCqD,sBAAsB,EAAErD,mBAAmB;EAC3CsD,uBAAuB,EAAEtD,mBAAmB;EAC5CuD,SAAS,EAAEtD;AACf,CAAC;AAED,SAAS8C,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}