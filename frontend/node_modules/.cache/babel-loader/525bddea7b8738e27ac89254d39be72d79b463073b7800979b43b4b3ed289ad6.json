{"ast":null,"code":"import { setTarget } from './setters.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { transformProps } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { createMotionValueAnimation } from '../../animation/index.mjs';\nimport { sync } from '../../frameloop/index.mjs';\nfunction animateVisualElement(visualElement, definition) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  visualElement.notify(\"AnimationStart\", definition);\n  let animation;\n  if (Array.isArray(definition)) {\n    const animations = definition.map(variant => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  const resolved = resolveVariant(visualElement, variant, options.custom);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\r\n   * If we have a variant, create a callback that runs it as an animation.\r\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n   */\n  const getAnimation = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();\n  /**\r\n   * If we have children, create a callback that runs all their animations.\r\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n   */\n  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function () {\n    let forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\r\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n   * this animation or all children animations before playing the other.\r\n   */\n  const {\n    when\n  } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\r\n * @internal\r\n */\nfunction animateTarget(visualElement, definition) {\n  let {\n    delay = 0,\n    transitionOverride,\n    type\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  let {\n    transition = visualElement.getDefaultTransition(),\n    transitionEnd,\n    ...target\n  } = visualElement.makeTargetAnimatable(definition);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  const animations = [];\n  const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    const valueTransition = {\n      delay,\n      elapsed: 0,\n      ...transition\n    };\n    /**\r\n     * If this is the first time a value is being animated, check\r\n     * to see if we're handling off from an existing animation.\r\n     */\n    if (window.HandoffAppearAnimations && !value.hasAnimated) {\n      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n      if (appearId) {\n        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);\n      }\n    }\n    let animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? {\n      type: false\n    } : valueTransition));\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(() => willChange.remove(key));\n    }\n    animations.push(animation);\n  }\n  return Promise.all(animations).then(() => {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant) {\n  let delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  let options = arguments.length > 5 ? arguments[5] : undefined;\n  const animations = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? function () {\n    let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return i * staggerChildren;\n  } : function () {\n    let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, {\n      ...options,\n      delay: delayChildren + generateStaggerDuration(i)\n    }).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(value => value.stop());\n}\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\nfunction shouldBlockAnimation(_ref, key) {\n  let {\n    protectedKeys,\n    needsAnimating\n  } = _ref;\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"names":["setTarget","resolveVariant","transformProps","isWillChangeMotionValue","optimizedAppearDataAttribute","createMotionValueAnimation","sync","animateVisualElement","visualElement","definition","options","arguments","length","undefined","notify","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","_a","resolved","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","delay","type","transitionEnd","target","makeTargetAnimatable","willChange","getValue","animationTypeState","animationState","getState","key","value","valueTarget","shouldBlockAnimation","valueTransition","elapsed","window","HandoffAppearAnimations","hasAnimated","appearId","getProps","start","shouldReduceMotion","has","add","remove","push","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","values","stop","a","b","sortNodePosition","_ref","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"sources":["C:/Users/Кирилл/Desktop/here/pears/frontend/node_modules/framer-motion/dist/es/render/utils/animation.mjs"],"sourcesContent":["import { setTarget } from './setters.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\nimport { transformProps } from '../html/utils/transform.mjs';\r\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\r\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\r\nimport { createMotionValueAnimation } from '../../animation/index.mjs';\r\nimport { sync } from '../../frameloop/index.mjs';\r\n\r\nfunction animateVisualElement(visualElement, definition, options = {}) {\r\n    visualElement.notify(\"AnimationStart\", definition);\r\n    let animation;\r\n    if (Array.isArray(definition)) {\r\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\r\n        animation = Promise.all(animations);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        animation = animateVariant(visualElement, definition, options);\r\n    }\r\n    else {\r\n        const resolvedDefinition = typeof definition === \"function\"\r\n            ? resolveVariant(visualElement, definition, options.custom)\r\n            : definition;\r\n        animation = animateTarget(visualElement, resolvedDefinition, options);\r\n    }\r\n    return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\r\n}\r\nfunction animateVariant(visualElement, variant, options = {}) {\r\n    var _a;\r\n    const resolved = resolveVariant(visualElement, variant, options.custom);\r\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\r\n    if (options.transitionOverride) {\r\n        transition = options.transitionOverride;\r\n    }\r\n    /**\r\n     * If we have a variant, create a callback that runs it as an animation.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getAnimation = resolved\r\n        ? () => animateTarget(visualElement, resolved, options)\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If we have children, create a callback that runs all their animations.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\r\n        ? (forwardDelay = 0) => {\r\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\r\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\r\n        }\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n     * this animation or all children animations before playing the other.\r\n     */\r\n    const { when } = transition;\r\n    if (when) {\r\n        const [first, last] = when === \"beforeChildren\"\r\n            ? [getAnimation, getChildAnimations]\r\n            : [getChildAnimations, getAnimation];\r\n        return first().then(last);\r\n    }\r\n    else {\r\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\r\n    var _a;\r\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);\r\n    const willChange = visualElement.getValue(\"willChange\");\r\n    if (transitionOverride)\r\n        transition = transitionOverride;\r\n    const animations = [];\r\n    const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\r\n    for (const key in target) {\r\n        const value = visualElement.getValue(key);\r\n        const valueTarget = target[key];\r\n        if (!value ||\r\n            valueTarget === undefined ||\r\n            (animationTypeState &&\r\n                shouldBlockAnimation(animationTypeState, key))) {\r\n            continue;\r\n        }\r\n        const valueTransition = { delay, elapsed: 0, ...transition };\r\n        /**\r\n         * If this is the first time a value is being animated, check\r\n         * to see if we're handling off from an existing animation.\r\n         */\r\n        if (window.HandoffAppearAnimations && !value.hasAnimated) {\r\n            const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\r\n            if (appearId) {\r\n                valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);\r\n            }\r\n        }\r\n        let animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)\r\n            ? { type: false }\r\n            : valueTransition));\r\n        if (isWillChangeMotionValue(willChange)) {\r\n            willChange.add(key);\r\n            animation = animation.then(() => willChange.remove(key));\r\n        }\r\n        animations.push(animation);\r\n    }\r\n    return Promise.all(animations).then(() => {\r\n        transitionEnd && setTarget(visualElement, transitionEnd);\r\n    });\r\n}\r\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\r\n    const animations = [];\r\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\r\n    const generateStaggerDuration = staggerDirection === 1\r\n        ? (i = 0) => i * staggerChildren\r\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\r\n    Array.from(visualElement.variantChildren)\r\n        .sort(sortByTreeOrder)\r\n        .forEach((child, i) => {\r\n        child.notify(\"AnimationStart\", variant);\r\n        animations.push(animateVariant(child, variant, {\r\n            ...options,\r\n            delay: delayChildren + generateStaggerDuration(i),\r\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\r\n    });\r\n    return Promise.all(animations);\r\n}\r\nfunction stopAnimation(visualElement) {\r\n    visualElement.values.forEach((value) => value.stop());\r\n}\r\nfunction sortByTreeOrder(a, b) {\r\n    return a.sortNodePosition(b);\r\n}\r\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\r\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\r\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\r\n    needsAnimating[key] = false;\r\n    return shouldBlock;\r\n}\r\n\r\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}